{"version":3,"file":"index.cjs","sources":["../../../node_modules/.pnpm/nanoid@4.0.0/node_modules/nanoid/non-secure/index.js","../src/plugin/module-mapper.ts","../src/utils/is-module-tree.ts","../src/plugin/data.ts","../src/plugin/build-stats.ts","../src/plugin/compress.ts","../src/plugin/index.ts","../src/index.ts"],"sourcesContent":["let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import { customAlphabet } from \"nanoid/non-secure\";\n\nimport type { ModuleImport, ModuleMeta, ModulePart, ModuleLengths, ModuleUID } from \"../types/types\";\n\nconst nanoid = customAlphabet(\"1234567890abcdef\", 4);\n\nconst UNIQUE_PREFIX = nanoid();\nlet COUNTER = 0;\n\nconst uniqueId = (): ModuleUID => `${UNIQUE_PREFIX}-${COUNTER++}`;\n\ntype ModuleIdStorage = {\n  uid: ModuleUID;\n  meta: Omit<ModuleMeta, \"imported\" | \"importedBy\"> & { imported: Set<string>; importedBy: Set<string> };\n};\n\nexport class ModuleMapper {\n  private nodeParts: Record<ModuleUID, ModulePart> = {};\n  private nodeMetas: Record<string, ModuleIdStorage> = {};\n\n  constructor(private projectRoot: string | RegExp) {}\n\n  trimProjectRootId(moduleId: string): string {\n    return moduleId.replace(this.projectRoot, \"\");\n  }\n\n  getModuleUid(moduleId: string): ModuleUID {\n    if (!(moduleId in this.nodeMetas)) {\n      this.nodeMetas[moduleId] = {\n        uid: uniqueId(),\n        meta: { id: this.trimProjectRootId(moduleId), moduleParts: {}, imported: new Set(), importedBy: new Set() },\n      };\n    }\n\n    return this.nodeMetas[moduleId].uid;\n  }\n\n  getBundleModuleUid(bundleId: string, moduleId: string): ModuleUID {\n    if (!(moduleId in this.nodeMetas)) {\n      this.nodeMetas[moduleId] = {\n        uid: uniqueId(),\n        meta: { id: this.trimProjectRootId(moduleId), moduleParts: {}, imported: new Set(), importedBy: new Set() },\n      };\n    }\n    if (!(bundleId in this.nodeMetas[moduleId].meta.moduleParts)) {\n      this.nodeMetas[moduleId].meta.moduleParts[bundleId] = uniqueId();\n    }\n\n    return this.nodeMetas[moduleId].meta.moduleParts[bundleId];\n  }\n\n  setNodePart(bundleId: string, moduleId: string, value: ModuleLengths): ModuleUID {\n    const uid = this.getBundleModuleUid(bundleId, moduleId);\n    if (uid in this.nodeParts) {\n      throw new Error(\n        `Override module: bundle id ${bundleId}, module id ${moduleId}, value ${JSON.stringify(\n          value\n        )}, existing value: ${JSON.stringify(this.nodeParts[uid])}`\n      );\n    }\n    this.nodeParts[uid] = { ...value, mainUid: this.getModuleUid(moduleId) };\n    return uid;\n  }\n\n  setNodeMeta(moduleId: string, value: { isEntry?: boolean; isExternal?: boolean }): void {\n    this.getModuleUid(moduleId);\n    this.nodeMetas[moduleId].meta.isEntry = value.isEntry;\n    this.nodeMetas[moduleId].meta.isExternal = value.isExternal;\n  }\n\n  hasNodePart(bundleId: string, moduleId: string): boolean {\n    if (!(moduleId in this.nodeMetas)) {\n      return false;\n    }\n    if (!(bundleId in this.nodeMetas[moduleId].meta.moduleParts)) {\n      return false;\n    }\n    if (!(this.nodeMetas[moduleId].meta.moduleParts[bundleId] in this.nodeParts)) {\n      return false;\n    }\n    return true;\n  }\n\n  getNodeParts(): ModuleMapper[\"nodeParts\"] {\n    return this.nodeParts;\n  }\n\n  getNodeMetas(): Record<ModuleUID, ModuleMeta> {\n    const nodeMetas: Record<ModuleUID, ModuleMeta> = {};\n    for (const { uid, meta } of Object.values(this.nodeMetas)) {\n      nodeMetas[uid] = {\n        ...meta,\n        imported: [...meta.imported].map((rawImport) => {\n          const [uid, dynamic] = rawImport.split(\",\");\n          const importData: ModuleImport = { uid };\n          if (dynamic === \"true\") {\n            importData.dynamic = true;\n          }\n          return importData;\n        }),\n        importedBy: [...meta.importedBy].map((rawImport) => {\n          const [uid, dynamic] = rawImport.split(\",\");\n          const importData: ModuleImport = { uid };\n          if (dynamic === \"true\") {\n            importData.dynamic = true;\n          }\n          return importData;\n        }),\n      };\n    }\n    return nodeMetas;\n  }\n\n  addImportedByLink(targetId: string, sourceId: string): void {\n    const sourceUid = this.getModuleUid(sourceId);\n    this.getModuleUid(targetId);\n    this.nodeMetas[targetId].meta.importedBy.add(sourceUid);\n  }\n\n  addImportedLink(sourceId: string, targetId: string, dynamic = false): void {\n    const targetUid = this.getModuleUid(targetId);\n    this.getModuleUid(sourceId);\n    this.nodeMetas[sourceId].meta.imported.add(String([targetUid, dynamic]));\n  }\n}","import type { ModuleTree, ModuleTreeLeaf } from \"../types/types\";\n\nexport const isModuleTree = (mod: ModuleTree | ModuleTreeLeaf): mod is ModuleTree => \"children\" in mod;","import type { GetModuleInfo } from \"../types/rollup\";\nimport type { ModuleLengths, ModuleTree, ModuleTreeLeaf } from \"../types/types\";\n\nimport { isModuleTree } from \"../utils/is-module-tree\";\nimport { ModuleMapper } from \"./module-mapper\";\n\ninterface MappedNode {\n  uid: string;\n}\n\nconst addToPath = (moduleId: string, tree: ModuleTree, modulePath: string[], node: MappedNode): void => {\n  if (modulePath.length === 0) {\n    throw new Error(`Error adding node to path ${moduleId}`);\n  }\n\n  const [head, ...rest] = modulePath;\n\n  if (rest.length === 0) {\n    tree.children.push({ ...node, name: head });\n    return;\n  } else {\n    let newTree = tree.children.find((folder): folder is ModuleTree => folder.name === head && isModuleTree(folder));\n\n    if (!newTree) {\n      newTree = { name: head, children: [] };\n      tree.children.push(newTree);\n    }\n    addToPath(moduleId, newTree, rest, node);\n    return;\n  }\n};\n\n// TODO try to make it without recursion, but still typesafe\nconst mergeSingleChildTrees = (tree: ModuleTree): ModuleTree | ModuleTreeLeaf => {\n  if (tree.children.length === 1) {\n    const child = tree.children[0];\n    const name = `${tree.name}/${child.name}`;\n    if (isModuleTree(child)) {\n      tree.name = name;\n      tree.children = child.children;\n      return mergeSingleChildTrees(tree);\n    } else {\n      return {\n        name,\n        uid: child.uid,\n      };\n    }\n  } else {\n    tree.children = tree.children.map((node) => {\n      if (isModuleTree(node)) {\n        return mergeSingleChildTrees(node);\n      } else {\n        return node;\n      }\n    });\n    return tree;\n  }\n};\n\nexport const buildTree = (\n  bundleId: string,\n  modules: Array<ModuleLengths & { id: string }>,\n  mapper: ModuleMapper\n): ModuleTree => {\n  const tree: ModuleTree = {\n    name: bundleId,\n    children: [],\n  };\n\n  for (const { id, renderedLength, gzipLength, brotliLength } of modules) {\n    const bundleModuleUid = mapper.setNodePart(bundleId, id, { renderedLength, gzipLength, brotliLength });\n\n    const trimmedModuleId = mapper.trimProjectRootId(id);\n\n    const pathParts = trimmedModuleId.split(/\\\\|\\//).filter((p) => p !== \"\");\n    addToPath(trimmedModuleId, tree, pathParts, { uid: bundleModuleUid });\n  }\n\n  tree.children = tree.children.map((node) => {\n    if (isModuleTree(node)) {\n      return mergeSingleChildTrees(node);\n    } else {\n      return node;\n    }\n  });\n\n  return tree;\n};\n\nexport const mergeTrees = (trees: Array<ModuleTree | ModuleTreeLeaf>): ModuleTree => {\n  const newTree = {\n    name: \"root\",\n    children: trees,\n    isRoot: true,\n  };\n\n  return newTree;\n};\n\nexport const addLinks = (startModuleId: string, getModuleInfo: GetModuleInfo, mapper: ModuleMapper): void => {\n  const processedNodes: Record<string, boolean> = {};\n\n  const moduleIds = [startModuleId];\n\n  while (moduleIds.length > 0) {\n    const moduleId = moduleIds.shift() as string;\n\n    if (processedNodes[moduleId]) {\n      continue;\n    } else {\n      processedNodes[moduleId] = true;\n    }\n\n    const moduleInfo = getModuleInfo(moduleId);\n\n    if (!moduleInfo) {\n      return;\n    }\n\n    if (moduleInfo.isEntry) {\n      mapper.setNodeMeta(moduleId, { isEntry: true });\n    }\n    if (moduleInfo.isExternal) {\n      mapper.setNodeMeta(moduleId, { isExternal: true });\n    }\n\n    for (const importedId of moduleInfo.importedIds) {\n      mapper.addImportedByLink(importedId, moduleId);\n      mapper.addImportedLink(moduleId, importedId);\n\n      moduleIds.push(importedId);\n    }\n    for (const importedId of moduleInfo.dynamicallyImportedIds) {\n      mapper.addImportedByLink(importedId, moduleId);\n      mapper.addImportedLink(moduleId, importedId, true);\n\n      moduleIds.push(importedId);\n    }\n  }\n};","import type { VisualizerData } from \"../types/types\";\nimport type { TemplateType } from \"../types/template-types\";\n\nconst htmlEscape = (str: string) =>\n  str\n    .replace(/&/g, \"&amp;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n\ninterface BuildHtmlOptions {\n  title: string;\n  data: VisualizerData;\n  template: TemplateType;\n}\n\nexport async function buildHtml({ title, data, template }: BuildHtmlOptions): Promise<string> {\n  return `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n        <title>${htmlEscape(title)}</title>\n        <link rel='stylesheet' href='/js/${template}.min.css' />\n      </head>\n      <body>\n        <main></main>\n        <script type=\"module\" defer>\n          import * as drawChart from \"/js/${template}.min.js\";\n          const data = ${JSON.stringify(data)};\n          \n          const run = () => {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n            const chartNode = document.querySelector(\"main\");\n            drawChart.default(chartNode, data, width, height);\n          };\n      \n          window.addEventListener('resize', run);\n      \n          document.addEventListener('DOMContentLoaded', run);\n        </script>\n      </body>\n    </html>\n  `;\n}\n","// import { gzip, getWASM } from \"../../../deno/denoflate/mod\";\n// import { compress } from \"@bundlejs/core/src/deno/denoflate/mod\";\n\nexport type SizeGetter = (code: Uint8Array) => Promise<number>;\n\nexport const emptySizeGetter: SizeGetter = () => Promise.resolve(0);\nexport const gzipSizeGetter: SizeGetter = async (code: Uint8Array) => {\n    // @bundlejs/core/src/deno/denoflate/mod.ts\n    // ../../../core/src/deno/denoflate/mod\n    const { gzip, getWASM } = await import(\"@bundlejs/core/src/deno/denoflate/mod\");\n    await getWASM();\n\n    const data = await gzip(code, 9);\n    // const data = [];\n    return data.length;\n};\n\nexport const brotliSizeGetter: SizeGetter = async (code: Uint8Array) => {\n    // @bundlejs/core/deno/brotli/mod.ts\n    // ../../../core/src/deno/brotli/mod\n    const { compress } = await import(\"@bundlejs/core/src/deno/brotli/mod\");\n    const data = await compress(code, code.length, 11);\n    return data.length;\n};","import type { TemplateType } from \"../types/template-types\";\nimport type { ModuleLengths, ModuleTree, ModuleTreeLeaf, VisualizerData } from \"../types/types\";\nimport type { Metadata, MetadataOutput } from \"../types/metafile\";\nimport type { ModuleInfo } from \"../types/rollup\";\nimport type { OutputFile } from \"esbuild-wasm\";\n\nimport { ModuleMapper } from \"./module-mapper\";\nimport { addLinks, buildTree, mergeTrees } from \"./data\";\nimport { buildHtml } from \"./build-stats\";\n\nimport { gzipSizeGetter, brotliSizeGetter, emptySizeGetter } from \"./compress\";\n\n/**\n * Analyzer options\n */\nexport interface AnalyzerOptions {\n  title?: string;\n  template?: TemplateType | boolean;\n  gzipSize?: boolean;\n  brotliSize?: boolean;\n}\n\nexport const visualizer = async (metadata: Metadata, outputFiles: OutputFile[], opts: AnalyzerOptions = {}): Promise<string> => {\n  const title = opts.title ?? \"Esbuild Visualizer\";\n  const template = (opts.template == true ? \"treemap\" : opts.template as TemplateType) ?? \"treemap\";\n  const projectRoot = \"\";\n\n  let outputFilesMap = new Map<string, Uint8Array>();\n  outputFiles.forEach(({ path, contents }) => {\n    outputFilesMap.set(path, contents);\n  });\n  // console.log(metadata, outputFiles, Array.from(outputFilesMap.entries()));\n\n  const gzipSize = !!opts.gzipSize;\n  const brotliSize = !!opts.brotliSize;\n  const gzip = gzipSize ? gzipSizeGetter : emptySizeGetter;\n  const brotli = brotliSize ? brotliSizeGetter : emptySizeGetter;\n\n  const ModuleLengths = async ({\n    id,\n    mod\n  }: {\n    id: string;\n    mod: { bytesInOutput: number };\n  }): Promise<ModuleLengths & { id: string }> => {\n    const code = outputFilesMap.get(id);\n    let faultyCode = code == null || code == undefined || code?.length == 0;\n    let [gzipLength, brotliLength, renderedLength] = await Promise.all(faultyCode ? [0, 0, mod.bytesInOutput] : [gzip(code), brotli(code), code?.length])\n    const result = {\n      id,\n      gzipLength,\n      brotliLength,\n      renderedLength\n    };\n    return result;\n  };\n\n  const roots: Array<ModuleTree | ModuleTreeLeaf> = [];\n  const mapper = new ModuleMapper(projectRoot);\n\n  // collect trees\n  for (const [bundleId, bundle] of Object.entries(metadata.outputs)) {\n    const modules = await Promise.all(\n      Object\n        .entries(bundle.inputs)\n        .map(([id, mod]) => ModuleLengths({ id, mod }))\n    );\n    const tree = buildTree(bundleId, modules, mapper);\n\n    const code = outputFilesMap.get(bundleId);\n    if (tree.children.length === 0 && code) {\n      const bundleSizes = await ModuleLengths({\n        id: bundleId,\n        mod: { bytesInOutput: code?.length }\n      });\n\n      const facadeModuleId = `${bundleId}-unknown`;\n      const bundleUid = mapper.setNodePart(bundleId, facadeModuleId, bundleSizes);\n      mapper.setNodeMeta(facadeModuleId, { isEntry: true });\n      const leaf: ModuleTreeLeaf = { name: bundleId, uid: bundleUid };\n      roots.push(leaf);\n    } else {\n      roots.push(tree);\n    }\n  }\n\n  const getModuleInfo = (bundle: MetadataOutput) => (moduleId: string): ModuleInfo => {\n    const input = metadata.inputs?.[moduleId];\n\n    const imports = input?.imports.map((i) => i.path);\n\n    const code = outputFilesMap.get(moduleId);\n\n    return {\n      renderedLength: code?.length ?? bundle.inputs?.[moduleId]?.bytesInOutput ?? 0,\n      importedIds: imports ?? [],\n      dynamicallyImportedIds: [],\n      isEntry: bundle.entryPoint === moduleId,\n      isExternal: false,\n    };\n  };\n\n  for (const [bundleId, bundle] of Object.entries(metadata.outputs)) {\n    if (bundle.entryPoint == null) continue;\n\n    addLinks(bundleId, getModuleInfo(bundle), mapper);\n  }\n\n  const tree = mergeTrees(roots);\n\n  const data: VisualizerData = {\n    version: 3.0,\n    tree,\n    nodeParts: mapper.getNodeParts(),\n    nodeMetas: mapper.getNodeMetas(),\n    env: {},\n    options: {\n      gzip: gzipSize,\n      brotli: brotliSize\n    },\n  };\n\n  const fileContent: string = await buildHtml({\n    title,\n    data,\n    template,\n  });\n\n  return fileContent;\n};\n","// Based off of https://github.com/btd/esbuild-visualizer\nimport type { TemplateType } from \"./types/template-types\";\nimport type { ModuleMeta, ModulePart, ModuleTree, ModuleUID, VisualizerData } from \"./types/types\";\n\nimport type { Metadata } from \"./types/metafile\";\nimport type { OutputFile } from \"esbuild-wasm\";\nimport { AnalyzerOptions, visualizer } from \"./plugin/index\";\n\n\n/**\n * Generates interactive zoomable charts displaing the size of output files. \n * It's a great way to determine what causes the bundle size to be so large. \n */\n//  analysis?: TemplateType | boolean,\n//  metafile: Boolean(CONFIG.analysis),\nexport const analyze = async (metadata: Metadata, outputFiles: OutputFile[], opts: AnalyzerOptions = {}, logger = console.log) => {\n  try {\n    return await visualizer(metadata, outputFiles, {\n      title: \"Bundle Analysis\",\n      ...opts\n    });\n  } catch (err) {\n    let { stack } = (err as Error);\n    logger([`[Analyzer] ${err}`, stack], \"warning\");\n    console.warn(err, stack);\n  }\n};\n"],"names":[],"mappings":"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"}