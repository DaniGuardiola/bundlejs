{"version":3,"file":"index.mjs","sources":["../../../node_modules/.pnpm/nanoid@4.0.1/node_modules/nanoid/non-secure/index.js","../src/plugin/module-mapper.ts","../src/utils/is-module-tree.ts","../src/plugin/data.ts","../src/plugin/build-stats.ts","../src/plugin/compress.ts","../src/plugin/index.ts","../src/index.ts"],"sourcesContent":["let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import { customAlphabet } from \"nanoid/non-secure\";\n\nimport type { ModuleImport, ModuleMeta, ModulePart, ModuleLengths, ModuleUID } from \"../types/types\";\n\nconst nanoid = customAlphabet(\"1234567890abcdef\", 4);\n\nconst UNIQUE_PREFIX = nanoid();\nlet COUNTER = 0;\n\nconst uniqueId = (): ModuleUID => `${UNIQUE_PREFIX}-${COUNTER++}`;\n\ntype ModuleIdStorage = {\n  uid: ModuleUID;\n  meta: Omit<ModuleMeta, \"imported\" | \"importedBy\"> & { imported: Set<string>; importedBy: Set<string> };\n};\n\nexport class ModuleMapper {\n  private nodeParts: Record<ModuleUID, ModulePart> = {};\n  private nodeMetas: Record<string, ModuleIdStorage> = {};\n\n  constructor(private projectRoot: string | RegExp) {}\n\n  trimProjectRootId(moduleId: string): string {\n    return moduleId.replace(this.projectRoot, \"\");\n  }\n\n  getModuleUid(moduleId: string): ModuleUID {\n    if (!(moduleId in this.nodeMetas)) {\n      this.nodeMetas[moduleId] = {\n        uid: uniqueId(),\n        meta: { id: this.trimProjectRootId(moduleId), moduleParts: {}, imported: new Set(), importedBy: new Set() },\n      };\n    }\n\n    return this.nodeMetas[moduleId].uid;\n  }\n\n  getBundleModuleUid(bundleId: string, moduleId: string): ModuleUID {\n    if (!(moduleId in this.nodeMetas)) {\n      this.nodeMetas[moduleId] = {\n        uid: uniqueId(),\n        meta: { id: this.trimProjectRootId(moduleId), moduleParts: {}, imported: new Set(), importedBy: new Set() },\n      };\n    }\n    if (!(bundleId in this.nodeMetas[moduleId].meta.moduleParts)) {\n      this.nodeMetas[moduleId].meta.moduleParts[bundleId] = uniqueId();\n    }\n\n    return this.nodeMetas[moduleId].meta.moduleParts[bundleId];\n  }\n\n  setNodePart(bundleId: string, moduleId: string, value: ModuleLengths): ModuleUID {\n    const uid = this.getBundleModuleUid(bundleId, moduleId);\n    if (uid in this.nodeParts) {\n      throw new Error(\n        `Override module: bundle id ${bundleId}, module id ${moduleId}, value ${JSON.stringify(\n          value\n        )}, existing value: ${JSON.stringify(this.nodeParts[uid])}`\n      );\n    }\n    this.nodeParts[uid] = { ...value, mainUid: this.getModuleUid(moduleId) };\n    return uid;\n  }\n\n  setNodeMeta(moduleId: string, value: { isEntry?: boolean; isExternal?: boolean }): void {\n    this.getModuleUid(moduleId);\n    this.nodeMetas[moduleId].meta.isEntry = value.isEntry;\n    this.nodeMetas[moduleId].meta.isExternal = value.isExternal;\n  }\n\n  hasNodePart(bundleId: string, moduleId: string): boolean {\n    if (!(moduleId in this.nodeMetas)) {\n      return false;\n    }\n    if (!(bundleId in this.nodeMetas[moduleId].meta.moduleParts)) {\n      return false;\n    }\n    if (!(this.nodeMetas[moduleId].meta.moduleParts[bundleId] in this.nodeParts)) {\n      return false;\n    }\n    return true;\n  }\n\n  getNodeParts(): ModuleMapper[\"nodeParts\"] {\n    return this.nodeParts;\n  }\n\n  getNodeMetas(): Record<ModuleUID, ModuleMeta> {\n    const nodeMetas: Record<ModuleUID, ModuleMeta> = {};\n    for (const { uid, meta } of Object.values(this.nodeMetas)) {\n      nodeMetas[uid] = {\n        ...meta,\n        imported: [...meta.imported].map((rawImport) => {\n          const [uid, dynamic] = rawImport.split(\",\");\n          const importData: ModuleImport = { uid };\n          if (dynamic === \"true\") {\n            importData.dynamic = true;\n          }\n          return importData;\n        }),\n        importedBy: [...meta.importedBy].map((rawImport) => {\n          const [uid, dynamic] = rawImport.split(\",\");\n          const importData: ModuleImport = { uid };\n          if (dynamic === \"true\") {\n            importData.dynamic = true;\n          }\n          return importData;\n        }),\n      };\n    }\n    return nodeMetas;\n  }\n\n  addImportedByLink(targetId: string, sourceId: string): void {\n    const sourceUid = this.getModuleUid(sourceId);\n    this.getModuleUid(targetId);\n    this.nodeMetas[targetId].meta.importedBy.add(sourceUid);\n  }\n\n  addImportedLink(sourceId: string, targetId: string, dynamic = false): void {\n    const targetUid = this.getModuleUid(targetId);\n    this.getModuleUid(sourceId);\n    this.nodeMetas[sourceId].meta.imported.add(String([targetUid, dynamic]));\n  }\n}","import type { ModuleTree, ModuleTreeLeaf } from \"../types/types\";\n\nexport const isModuleTree = (mod: ModuleTree | ModuleTreeLeaf): mod is ModuleTree => \"children\" in mod;","import type { GetModuleInfo } from \"../types/rollup\";\nimport type { ModuleLengths, ModuleTree, ModuleTreeLeaf } from \"../types/types\";\n\nimport { isModuleTree } from \"../utils/is-module-tree\";\nimport { ModuleMapper } from \"./module-mapper\";\n\ninterface MappedNode {\n  uid: string;\n}\n\nconst addToPath = (moduleId: string, tree: ModuleTree, modulePath: string[], node: MappedNode): void => {\n  if (modulePath.length === 0) {\n    throw new Error(`Error adding node to path ${moduleId}`);\n  }\n\n  const [head, ...rest] = modulePath;\n\n  if (rest.length === 0) {\n    tree.children.push({ ...node, name: head });\n    return;\n  } else {\n    let newTree = tree.children.find((folder): folder is ModuleTree => folder.name === head && isModuleTree(folder));\n\n    if (!newTree) {\n      newTree = { name: head, children: [] };\n      tree.children.push(newTree);\n    }\n    addToPath(moduleId, newTree, rest, node);\n    return;\n  }\n};\n\n// TODO try to make it without recursion, but still typesafe\nconst mergeSingleChildTrees = (tree: ModuleTree): ModuleTree | ModuleTreeLeaf => {\n  if (tree.children.length === 1) {\n    const child = tree.children[0];\n    const name = `${tree.name}/${child.name}`;\n    if (isModuleTree(child)) {\n      tree.name = name;\n      tree.children = child.children;\n      return mergeSingleChildTrees(tree);\n    } else {\n      return {\n        name,\n        uid: child.uid,\n      };\n    }\n  } else {\n    tree.children = tree.children.map((node) => {\n      if (isModuleTree(node)) {\n        return mergeSingleChildTrees(node);\n      } else {\n        return node;\n      }\n    });\n    return tree;\n  }\n};\n\nexport const buildTree = (\n  bundleId: string,\n  modules: Array<ModuleLengths & { id: string }>,\n  mapper: ModuleMapper\n): ModuleTree => {\n  const tree: ModuleTree = {\n    name: bundleId,\n    children: [],\n  };\n\n  for (const { id, renderedLength, gzipLength, brotliLength } of modules) {\n    const bundleModuleUid = mapper.setNodePart(bundleId, id, { renderedLength, gzipLength, brotliLength });\n\n    const trimmedModuleId = mapper.trimProjectRootId(id);\n\n    const pathParts = trimmedModuleId.split(/\\\\|\\//).filter((p) => p !== \"\");\n    addToPath(trimmedModuleId, tree, pathParts, { uid: bundleModuleUid });\n  }\n\n  tree.children = tree.children.map((node) => {\n    if (isModuleTree(node)) {\n      return mergeSingleChildTrees(node);\n    } else {\n      return node;\n    }\n  });\n\n  return tree;\n};\n\nexport const mergeTrees = (trees: Array<ModuleTree | ModuleTreeLeaf>): ModuleTree => {\n  const newTree = {\n    name: \"root\",\n    children: trees,\n    isRoot: true,\n  };\n\n  return newTree;\n};\n\nexport const addLinks = (startModuleId: string, getModuleInfo: GetModuleInfo, mapper: ModuleMapper): void => {\n  const processedNodes: Record<string, boolean> = {};\n\n  const moduleIds = [startModuleId];\n\n  while (moduleIds.length > 0) {\n    const moduleId = moduleIds.shift() as string;\n\n    if (processedNodes[moduleId]) {\n      continue;\n    } else {\n      processedNodes[moduleId] = true;\n    }\n\n    const moduleInfo = getModuleInfo(moduleId);\n\n    if (!moduleInfo) {\n      return;\n    }\n\n    if (moduleInfo.isEntry) {\n      mapper.setNodeMeta(moduleId, { isEntry: true });\n    }\n    if (moduleInfo.isExternal) {\n      mapper.setNodeMeta(moduleId, { isExternal: true });\n    }\n\n    for (const importedId of moduleInfo.importedIds) {\n      mapper.addImportedByLink(importedId, moduleId);\n      mapper.addImportedLink(moduleId, importedId);\n\n      moduleIds.push(importedId);\n    }\n    for (const importedId of moduleInfo.dynamicallyImportedIds) {\n      mapper.addImportedByLink(importedId, moduleId);\n      mapper.addImportedLink(moduleId, importedId, true);\n\n      moduleIds.push(importedId);\n    }\n  }\n};","import type { VisualizerData } from \"../types/types\";\nimport type { TemplateType } from \"../types/template-types\";\n\nconst htmlEscape = (str: string) =>\n  str\n    .replace(/&/g, \"&amp;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n\ninterface BuildHtmlOptions {\n  title: string;\n  data: VisualizerData;\n  template: TemplateType;\n}\n\nexport async function buildHtml({ title, data, template }: BuildHtmlOptions): Promise<string> {\n  return `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n        <title>${htmlEscape(title)}</title>\n        <link rel='stylesheet' href='/js/${template}.min.css' />\n      </head>\n      <body>\n        <main></main>\n        <script type=\"module\" defer>\n          import * as drawChart from \"/js/${template}.min.js\";\n          const data = ${JSON.stringify(data)};\n          \n          const run = () => {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n            const chartNode = document.querySelector(\"main\");\n            drawChart.default(chartNode, data, width, height);\n          };\n      \n          window.addEventListener('resize', run);\n      \n          document.addEventListener('DOMContentLoaded', run);\n        </script>\n      </body>\n    </html>\n  `;\n}\n","// import { gzip, getWASM } from \"../../../deno/denoflate/mod\";\n// import { compress } from \"@bundlejs/core/src/deno/denoflate/mod\";\n\nexport type SizeGetter = (code: Uint8Array) => Promise<number>;\n\nexport const emptySizeGetter: SizeGetter = () => Promise.resolve(0);\nexport const gzipSizeGetter: SizeGetter = async (code: Uint8Array) => {\n    // @bundlejs/core/src/deno/denoflate/mod.ts\n    // ../../../core/src/deno/denoflate/mod\n    const { gzip, getWASM } = await import(\"@bundlejs/core/src/deno/denoflate/mod\");\n    await getWASM();\n\n    const data = await gzip(code, 9);\n    // const data = [];\n    return data.length;\n};\n\nexport const brotliSizeGetter: SizeGetter = async (code: Uint8Array) => {\n    // @bundlejs/core/deno/brotli/mod.ts\n    // ../../../core/src/deno/brotli/mod\n    const { compress } = await import(\"@bundlejs/core/src/deno/brotli/mod\");\n    const data = await compress(code, code.length, 11);\n    return data.length;\n};","import type { TemplateType } from \"../types/template-types\";\nimport type { ModuleLengths, ModuleTree, ModuleTreeLeaf, VisualizerData } from \"../types/types\";\nimport type { Metadata, MetadataOutput } from \"../types/metafile\";\nimport type { ModuleInfo } from \"../types/rollup\";\nimport type { OutputFile } from \"esbuild-wasm\";\n\nimport { ModuleMapper } from \"./module-mapper\";\nimport { addLinks, buildTree, mergeTrees } from \"./data\";\nimport { buildHtml } from \"./build-stats\";\n\nimport { gzipSizeGetter, brotliSizeGetter, emptySizeGetter } from \"./compress\";\n\n/**\n * Analyzer options\n */\nexport interface AnalyzerOptions {\n  title?: string;\n  template?: TemplateType | boolean;\n  gzipSize?: boolean;\n  brotliSize?: boolean;\n}\n\nexport const visualizer = async (metadata: Metadata, outputFiles: OutputFile[], opts: AnalyzerOptions = {}): Promise<string> => {\n  const title = opts.title ?? \"Esbuild Visualizer\";\n  const template = (opts.template == true ? \"treemap\" : opts.template as TemplateType) ?? \"treemap\";\n  const projectRoot = \"\";\n\n  let outputFilesMap = new Map<string, Uint8Array>();\n  outputFiles.forEach(({ path, contents }) => {\n    outputFilesMap.set(path, contents);\n  });\n  // console.log(metadata, outputFiles, Array.from(outputFilesMap.entries()));\n\n  const gzipSize = !!opts.gzipSize;\n  const brotliSize = !!opts.brotliSize;\n  const gzip = gzipSize ? gzipSizeGetter : emptySizeGetter;\n  const brotli = brotliSize ? brotliSizeGetter : emptySizeGetter;\n\n  const ModuleLengths = async ({\n    id,\n    mod\n  }: {\n    id: string;\n    mod: { bytesInOutput: number };\n  }): Promise<ModuleLengths & { id: string }> => {\n    const code = outputFilesMap.get(id);\n    let faultyCode = code == null || code == undefined || code?.length == 0;\n    let [gzipLength, brotliLength, renderedLength] = await Promise.all(faultyCode ? [0, 0, mod.bytesInOutput] : [gzip(code), brotli(code), code?.length])\n    const result = {\n      id,\n      gzipLength,\n      brotliLength,\n      renderedLength\n    };\n    return result;\n  };\n\n  const roots: Array<ModuleTree | ModuleTreeLeaf> = [];\n  const mapper = new ModuleMapper(projectRoot);\n\n  // collect trees\n  for (const [bundleId, bundle] of Object.entries(metadata.outputs)) {\n    const modules = await Promise.all(\n      Object\n        .entries(bundle.inputs)\n        .map(([id, mod]) => ModuleLengths({ id, mod }))\n    );\n    const tree = buildTree(bundleId, modules, mapper);\n\n    const code = outputFilesMap.get(bundleId);\n    if (tree.children.length === 0 && code) {\n      const bundleSizes = await ModuleLengths({\n        id: bundleId,\n        mod: { bytesInOutput: code?.length }\n      });\n\n      const facadeModuleId = `${bundleId}-unknown`;\n      const bundleUid = mapper.setNodePart(bundleId, facadeModuleId, bundleSizes);\n      mapper.setNodeMeta(facadeModuleId, { isEntry: true });\n      const leaf: ModuleTreeLeaf = { name: bundleId, uid: bundleUid };\n      roots.push(leaf);\n    } else {\n      roots.push(tree);\n    }\n  }\n\n  const getModuleInfo = (bundle: MetadataOutput) => (moduleId: string): ModuleInfo => {\n    const input = metadata.inputs?.[moduleId];\n\n    const imports = input?.imports.map((i) => i.path);\n\n    const code = outputFilesMap.get(moduleId);\n\n    return {\n      renderedLength: code?.length ?? bundle.inputs?.[moduleId]?.bytesInOutput ?? 0,\n      importedIds: imports ?? [],\n      dynamicallyImportedIds: [],\n      isEntry: bundle.entryPoint === moduleId,\n      isExternal: false,\n    };\n  };\n\n  for (const [bundleId, bundle] of Object.entries(metadata.outputs)) {\n    if (bundle.entryPoint == null) continue;\n\n    addLinks(bundleId, getModuleInfo(bundle), mapper);\n  }\n\n  const tree = mergeTrees(roots);\n\n  const data: VisualizerData = {\n    version: 3.0,\n    tree,\n    nodeParts: mapper.getNodeParts(),\n    nodeMetas: mapper.getNodeMetas(),\n    env: {},\n    options: {\n      gzip: gzipSize,\n      brotli: brotliSize\n    },\n  };\n\n  const fileContent: string = await buildHtml({\n    title,\n    data,\n    template,\n  });\n\n  return fileContent;\n};\n","// Based off of https://github.com/btd/esbuild-visualizer\nimport type { TemplateType } from \"./types/template-types\";\nimport type { ModuleMeta, ModulePart, ModuleTree, ModuleUID, VisualizerData } from \"./types/types\";\n\nimport type { Metadata } from \"./types/metafile\";\nimport type { OutputFile } from \"esbuild-wasm\";\nimport { AnalyzerOptions, visualizer } from \"./plugin/index\";\n\n\n/**\n * Generates interactive zoomable charts displaing the size of output files. \n * It's a great way to determine what causes the bundle size to be so large. \n */\n//  analysis?: TemplateType | boolean,\n//  metafile: Boolean(CONFIG.analysis),\nexport const analyze = async (metadata: Metadata, outputFiles: OutputFile[], opts: AnalyzerOptions = {}, logger = console.log) => {\n  try {\n    return await visualizer(metadata, outputFiles, {\n      title: \"Bundle Analysis\",\n      ...opts\n    });\n  } catch (err) {\n    let { stack } = (err as Error);\n    logger([`[Analyzer] ${err}`, stack], \"warning\");\n    console.warn(err, stack);\n  }\n};\n"],"names":["customAlphabet","alphabet","defaultSize","size","id","nanoid","UNIQUE_PREFIX","COUNTER","uniqueId","ModuleMapper","projectRoot","moduleId","bundleId","value","uid","nodeMetas","meta","rawImport","dynamic","importData","targetId","sourceId","sourceUid","targetUid","isModuleTree","mod","addToPath","tree","modulePath","node","head","rest","newTree","folder","mergeSingleChildTrees","child","name","buildTree","modules","mapper","renderedLength","gzipLength","brotliLength","bundleModuleUid","trimmedModuleId","pathParts","p","mergeTrees","trees","addLinks","startModuleId","getModuleInfo","processedNodes","moduleIds","moduleInfo","importedId","htmlEscape","str","buildHtml","title","data","template","emptySizeGetter","gzipSizeGetter","code","gzip","getWASM","brotliSizeGetter","compress","visualizer","metadata","outputFiles","opts","outputFilesMap","path","contents","gzipSize","brotliSize","brotli","ModuleLengths","faultyCode","roots","bundle","bundleSizes","facadeModuleId","bundleUid","leaf","imports","i","analyze","logger","err","stack"],"mappings":"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"}