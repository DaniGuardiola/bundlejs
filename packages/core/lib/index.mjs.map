{"version":3,"file":"index.mjs","sources":["../src/utils/encode-decode.ts","../src/utils/util-cdn.ts","../src/plugins/external.ts","../src/utils/fetch-and-cache.ts","../src/deno/path/_constants.ts","../src/deno/path/_util.ts","../src/deno/path/posix.ts","../src/deno/path/glob.ts","../src/deno/path/mod.ts","../src/utils/path.ts","../src/utils/loader.ts","../src/utils/resolve-exports.ts","../src/utils/parse-package-name.ts","../src/utils/resolve-imports.ts","../src/plugins/cdn.ts","../src/plugins/http.ts","../src/plugins/alias.ts","../src/plugins/virtual-fs.ts","../src/configs/platform.ts","../src/utils/filesystem.ts","../src/utils/deep-equal.ts","../src/configs/options.ts","../../../node_modules/.pnpm/@okikio+emitter@2.1.7/node_modules/@okikio/emitter/lib/api.es.js","../src/configs/events.ts","../src/configs/state.ts","../src/utils/pretty-bytes.ts","../src/utils/ansi.ts","../src/utils/create-notice.ts","../src/build.ts","../src/utils/debounce.ts","../src/utils/lz-string.ts","../src/utils/parse-query.ts","../src/utils/semver.ts","../src/utils/npm-search.ts","../src/deno/brotli/mod.ts","../src/deno/denoflate/mod.ts","../src/deno/lz4/mod.ts","../src/deno/base64/mod.ts"],"sourcesContent":["// export const { encode } = new TextEncoder();\n// export const { decode } = new TextDecoder();\n\nexport const encode = (str: string) => new TextEncoder().encode(str);\nexport const decode = (buf: BufferSource) => new TextDecoder().decode(buf);","/**\n * The default CDN host\n */\nexport const DEFAULT_CDN_HOST = 'https://unpkg.com';\n\n/**\n * Returns the CDN style supported by certain CDN's\n * e.g. \n * - `npm` - unpkg, skypack, esm.sh, and jsdelivr all support `npm` style imports for example they support adding versions to their URLs like this `https://unpkg.com/@okikio/animate@beta`\n * - `github` - github, and jsdelivr.gh both support `github` style imports, as in they don't support adding versions to their URLs like this `https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js`\n * - `deno` - deno supports `deno` style imports, as in they don't support adding versions to their URLs like this `https://deno.land/x/brotli/mod.ts`\n * - `other` - CDNs that haven't been added to the list\n */\nexport const getCDNStyle = (urlStr: string) => {\n  if (\n    /^(skypack|esm|esm\\.sh|unpkg|jsdelivr|esm\\.run)\\:?/.test(urlStr) ||\n    /^https?:\\/\\/(cdn\\.skypack\\.dev|cdn\\.esm\\.sh|cdn\\.jsdelivr\\.net\\/npm|unpkg\\.com)/.test(urlStr)\n  ) return \"npm\";\n\n  else if (\n    /^(jsdelivr\\.gh|github)\\:?/.test(urlStr) ||\n    /^https?:\\/\\/(cdn\\.jsdelivr\\.net\\/gh|raw\\.githubusercontent\\.com)/.test(urlStr)\n  ) return \"github\";\n\n  else if (\n    /^(deno)\\:?/.test(urlStr) ||\n    /^https?:\\/\\/(deno\\.land\\/x)/.test(urlStr)\n  ) return \"deno\";\n\n  return \"other\";\n}\n\n/**\n * Based on the URL scheme of the import, this method will return an actual CDN host origin to use,\n * e.g. \n * ```ts\n * getCDNHost(\"react\") //= https://unpkg.com\n * getCDNHost(\"react\", \"https://cdn.skypack.dev\") //= https://cdn.skypack.dev/\n * \n * // CDN URL Schemes take precedence above everything\n * getCDNHost(\"esm:react\", \"https://cdn.skypack.dev\") //= https://cdn.esm.sh/\n * ```\n * \n * > _**Note**: The returned CDN URL string will end with a '/' e.g. `https://cdn.esm.sh/`_\n * \n * @param importStr imports to find a CDN for\n * @param cdn The default CDN host to use. This can change based on the config of the user. This may be diregarded if the `importStr` has a CDN URL Scheme\n * @returns CDN URL host string\n */\nexport const getCDNOrigin = (importStr: string, cdn = DEFAULT_CDN_HOST) => {\n  // `skypack:` --> `https://cdn.skypack.dev`\n  if (/^skypack\\:/.test(importStr))\n    cdn = `https://cdn.skypack.dev`;\n\n  // `esm.sh:` or `esm:` --> `https://cdn.esm.sh`\n  else if (/^(esm\\.sh|esm)\\:/.test(importStr))\n    cdn = `https://cdn.esm.sh`;\n\n  // `unpkg:` --> `https://unpkg.com`\n  else if (/^unpkg\\:/.test(importStr))\n    cdn = `https://unpkg.com`;\n\n  // (NPM) `jsdelivr:` or `esm.run:` --> `https://cdn.jsdelivr.net/npm`\n  else if (/^(jsdelivr|esm\\.run)\\:/.test(importStr))\n    cdn = `https://cdn.jsdelivr.net/npm`;\n\n  // (GitHub) `jsdelivr.gh:` --> `https://cdn.jsdelivr.net/gh`\n  else if (/^(jsdelivr\\.gh)\\:/.test(importStr))\n    cdn = `https://cdn.jsdelivr.net/gh`;\n\n  // `deno:` --> `https://deno.land/x`\n  else if (/^(deno)\\:/.test(importStr))\n    cdn = `https://deno.land/x`;\n\n  // `github:` --> `https://raw.githubusercontent.com`\n  else if (/^(github)\\:/.test(importStr))\n    cdn = `https://raw.githubusercontent.com`;\n\n  return /\\/$/.test(cdn) ? cdn : `${cdn}/`;\n}\n\n/**\n * Remove CDN URL Schemes like `deno:...`, `unpkg:...`, etc... and known CDN hosts, e.g. `https://raw.githubusercontent.com/...`, `https://cdn.skypack.dev/...`, etc...  Leaving only the import path\n */\nexport const getPureImportPath = (importStr: string) =>\n  importStr\n    .replace(/^(skypack|esm|esm\\.sh|unpkg|jsdelivr|jsdelivr\\.gh|esm\\.run|deno|github)\\:/, \"\")\n    .replace(/^https?:\\/\\/(cdn\\.skypack\\.dev|cdn\\.esm\\.sh|cdn\\.jsdelivr\\.net\\/npm|unpkg\\.com|cdn\\.jsdelivr\\.net\\/gh|raw\\.githubusercontent\\.com|deno\\.land\\/x)/, \"\")\n    .replace(/^\\//, \"\");\n\n/**\n * Generates a CDN URL for an import, taking advantage of CDN URL Schemes in imports and the default CDN hosts parameter to decide the CDN host\n * Read through {@link getCDNOrigin} and {@link getPureImportPath}\n */\nexport const getCDNUrl = (importStr: string, cdn = DEFAULT_CDN_HOST) => {\n  let origin = getCDNOrigin(importStr, cdn);\n  let path = getPureImportPath(importStr);\n  let url = new URL(path, origin);\n  return { import: importStr, path, origin, cdn, url };\n}\n\n","import type { Plugin } from 'esbuild-wasm';\nimport type { BundleConfigOptions } from '../configs/options';\nimport type { EVENTS } from '../configs/events';\nimport type { STATE } from '../configs/state';\n\nimport { encode } from \"../utils/encode-decode\";\nimport { getCDNUrl } from '../utils/util-cdn';\n\n/** External Plugin Namespace */\nexport const EXTERNALS_NAMESPACE = 'external-globals';\n\n/** An empty export as a Uint8Array */\nexport const EMPTY_EXPORT = encode(`export default {}`);\n\n/** List of polyfillable native node modules, you should now use aliases to polyfill features */\nexport const PolyfillMap = {\n  \"console\": 'console-browserify',\n  \"constants\": 'constants-browserify',\n  \"crypto\": 'crypto-browserify',\n  \"http\": 'http-browserify',\n  \"buffer\": 'buffer',\n  \"Dirent\": \"dirent\",\n  \"vm\": 'vm-browserify',\n  \"zlib\": 'zlib-browserify',\n  \"assert\": 'assert',\n  \"child_process\": 'child_process',\n  \"cluster\": 'child_process',\n  \"dgram\": 'dgram',\n  \"dns\": 'dns',\n  \"domain\": 'domain-browser',\n  \"events\": 'events',\n  \"https\": 'https',\n  \"module\": 'module',\n  \"net\": 'net',\n  \"path\": 'path-browserify',\n  \"punycode\": 'punycode',\n  \"querystring\": 'querystring',\n  \"readline\": 'readline',\n  \"repl\": 'repl',\n  \"stream\": 'stream',\n  \"string_decoder\": 'string_decoder',\n  \"sys\": 'sys',\n  \"timers\": 'timers',\n  \"tls\": 'tls',\n  \"tty\": 'tty-browserify',\n  \"url\": 'url',\n  \"util\": 'util',\n  \"_shims\": '_shims',\n  \"_stream_duplex\": '_stream_duplex',\n  \"_stream_readable\": '_stream_readable',\n  \"_stream_writable\": '_stream_writable',\n  \"_stream_transform\": '_stream_transform',\n  \"_stream_passthrough\": '_stream_passthrough',\n  process: 'process/browser',\n  fs: 'memfs',\n  os: 'os-browserify/browser',\n  'v8': \"v8\",\n  \"node-inspect\": \"node-inspect\",\n  \"_linklist\": \"_linklist\",\n  \"_stream_wrap\": \"_stream_wrap\"\n};\n\n/** Array of native node packages (that are polyfillable) */\nexport const PolyfillKeys = Object.keys(PolyfillMap);\n/** API's & Packages that were later removed from nodejs */\nexport const DeprecatedAPIs = [\"v8/tools/codemap\", \"v8/tools/consarray\", \"v8/tools/csvparser\", \"v8/tools/logreader\", \"v8/tools/profile_view\", \"v8/tools/profile\", \"v8/tools/SourceMap\", \"v8/tools/splaytree\", \"v8/tools/tickprocessor-driver\", \"v8/tools/tickprocessor\", \"node-inspect/lib/_inspect\", \"node-inspect/lib/internal/inspect_client \", \"node-inspect/lib/internal/inspect_repl\", \"_linklist\", \"_stream_wrap\"];\n/** Packages `bundle` should ignore, including deprecated apis, and polyfillable API's */\nexport const ExternalPackages = ['chokidar', 'yargs', 'fsevents', `worker_threads`, \"async_hooks\", \"diagnostics_channel\", \"http2\", \"inspector\", \"perf_hooks\", \"trace_events\", \"wasi\", ...DeprecatedAPIs, ...PolyfillKeys];\n\n/** Based on https://github.com/egoist/play-esbuild/blob/7e34470f9e6ddcd9376704cd8b988577ddcd46c9/src/lib/esbuild.ts#L51 */\nexport const isExternal = (id: string, external: string[] = []) => {\n  return [...ExternalPackages, ...external].find((it: string): boolean => {\n    if (it === id) return true; // import 'foo' & external: ['foo']\n    if (id.startsWith(`${it}/`)) return true; // import 'foo/bar.js' & external: ['foo']\n    return false;\n  });\n};\n\n/**\n * Esbuild EXTERNAL plugin \n * \n * @param external List of packages to marks as external\n */\nexport const EXTERNAL = (events: typeof EVENTS, state: typeof STATE, config: BundleConfigOptions): Plugin => {\n  const { external = [] } = config?.esbuild ?? {}; \n  return {\n    name: EXTERNALS_NAMESPACE,\n    setup(build) {\n      // Intercept import paths starting with \"http:\" and \"https:\" so\n      // esbuild doesn't attempt to map them to a file system location.\n      // Tag them with the \"http-url\" namespace to associate them with\n      // this plugin.\n      build.onResolve({ filter: /.*/ }, (args) => {\n        let path = args.path.replace(/^node\\:/, \"\");\n        let { path: argPath } = getCDNUrl(path);\n\n        if (isExternal(argPath, external)) {\n          return {\n            path: argPath,\n            namespace: EXTERNALS_NAMESPACE,\n            external: true\n          };\n        }\n      });\n\n      // When a URL is loaded, we want to actually download the content\n      // from the internet. This has just enough logic to be able to\n      // handle the example import from https://cdn.esm.sh/ but in reality this\n      // would probably need to be more complex.\n      // \n      // We also want to intercept all import paths inside downloaded\n      // files and resolve them against the original URL. All of these\n      // files will be in the \"http-url\" namespace. Make sure to keep\n      // the newly resolved URL in the \"http-url\" namespace so imports\n      // inside it will also be resolved as URLs recursively.\n      build.onLoad({ filter: /.*/, namespace: EXTERNALS_NAMESPACE }, (args) => {\n        return {\n          pluginName: EXTERNALS_NAMESPACE,\n          contents: EMPTY_EXPORT,\n          warnings: [{\n            text: `${args.path} is marked as an external module and will be ignored.`,\n            details: `\"${args.path}\" is a built-in node module thus can't be bundled by https://bundlejs.com, sorry about that.`\n          }]\n        };\n      });\n    },\n  };\n};","export const CACHE = new Map();\nexport const CACHE_NAME = 'EXTERNAL_FETCHES';\nexport const newRequest = async (cache: Cache, request: Request, fetchOpts?: RequestInit) => {\n  let networkResponse: Response = await fetch(request, fetchOpts);\n\n  let clonedResponse = networkResponse.clone();\n  if (\"caches\" in globalThis)\n    cache.put(request, clonedResponse);\n  else\n    CACHE.set(request, clonedResponse);\n\n  return networkResponse;\n};\n\nexport const getRequest = async (url: RequestInfo | URL, permanent: boolean = false, fetchOpts?: RequestInit) => {\n  let request = new Request(url.toString());\n  let response: Response;\n\n  let cache: Cache;\n  let cacheResponse: Response;\n\n  // In specific situations the browser will sometimes disable access to cache storage, \n  // so, I create my own in memory cache\n  if (\"caches\" in globalThis) {\n    cache = await caches.open(CACHE_NAME);\n    cacheResponse = await cache.match(request);\n  } else {\n    cacheResponse = CACHE.get(request);\n  }\n\n  response = cacheResponse;\n\n  // If permanent is true, use the cache first and only go to the network if there is nothing in the cache, \n  // otherwise, still use cache first, but in the background queue up a network request\n  if (!cacheResponse)\n    response = await newRequest(cache, request, fetchOpts);\n  else if (!permanent)\n    newRequest(cache, request, fetchOpts);\n\n  return response.clone();\n}\n","// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\n// Alphabet chars.\nexport const CHAR_UPPERCASE_A = 65; /* A */\nexport const CHAR_LOWERCASE_A = 97; /* a */\nexport const CHAR_UPPERCASE_Z = 90; /* Z */\nexport const CHAR_LOWERCASE_Z = 122; /* z */\n\n// Non-alphabetic chars.\nexport const CHAR_DOT = 46; /* . */\nexport const CHAR_FORWARD_SLASH = 47; /* / */\nexport const CHAR_BACKWARD_SLASH = 92; /* \\ */\nexport const CHAR_VERTICAL_LINE = 124; /* | */\nexport const CHAR_COLON = 58; /* : */\nexport const CHAR_QUESTION_MARK = 63; /* ? */\nexport const CHAR_UNDERSCORE = 95; /* _ */\nexport const CHAR_LINE_FEED = 10; /* \\n */\nexport const CHAR_CARRIAGE_RETURN = 13; /* \\r */\nexport const CHAR_TAB = 9; /* \\t */\nexport const CHAR_FORM_FEED = 12; /* \\f */\nexport const CHAR_EXCLAMATION_MARK = 33; /* ! */\nexport const CHAR_HASH = 35; /* # */\nexport const CHAR_SPACE = 32; /*   */\nexport const CHAR_NO_BREAK_SPACE = 160; /* \\u00A0 */\nexport const CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279; /* \\uFEFF */\nexport const CHAR_LEFT_SQUARE_BRACKET = 91; /* [ */\nexport const CHAR_RIGHT_SQUARE_BRACKET = 93; /* ] */\nexport const CHAR_LEFT_ANGLE_BRACKET = 60; /* < */\nexport const CHAR_RIGHT_ANGLE_BRACKET = 62; /* > */\nexport const CHAR_LEFT_CURLY_BRACKET = 123; /* { */\nexport const CHAR_RIGHT_CURLY_BRACKET = 125; /* } */\nexport const CHAR_HYPHEN_MINUS = 45; /* - */\nexport const CHAR_PLUS = 43; /* + */\nexport const CHAR_DOUBLE_QUOTE = 34; /* \" */\nexport const CHAR_SINGLE_QUOTE = 39; /* ' */\nexport const CHAR_PERCENT = 37; /* % */\nexport const CHAR_SEMICOLON = 59; /* ; */\nexport const CHAR_CIRCUMFLEX_ACCENT = 94; /* ^ */\nexport const CHAR_GRAVE_ACCENT = 96; /* ` */\nexport const CHAR_AT = 64; /* @ */\nexport const CHAR_AMPERSAND = 38; /* & */\nexport const CHAR_EQUAL = 61; /* = */\n\n// Digits\nexport const CHAR_0 = 48; /* 0 */\nexport const CHAR_9 = 57; /* 9 */\n\nexport const SEP = \"/\";\nexport const SEP_PATTERN = /\\/+/;\n\nexport type OSType = \"windows\" | \"linux\" | \"darwin\";","// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport type { FormatInputPathObject } from \"./_interface\";\nimport {\n  CHAR_BACKWARD_SLASH,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_UPPERCASE_A,\n  CHAR_UPPERCASE_Z,\n} from \"./_constants\";\n\nexport function assertPath(path: string): void {\n  if (typeof path !== \"string\") {\n    throw new TypeError(\n      `Path must be a string. Received ${JSON.stringify(path)}`,\n    );\n  }\n}\n\nexport function isPosixPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nexport function isPathSeparator(code: number): boolean {\n  return isPosixPathSeparator(code) || code === CHAR_BACKWARD_SLASH;\n}\n\nexport function isWindowsDeviceRoot(code: number): boolean {\n  return (\n    (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n    (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z)\n  );\n}\n\n// Resolves . and .. elements in a path with directory names\nexport function normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code: number) => boolean,\n): string {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code: number | undefined;\n  for (let i = 0, len = path.length; i <= len; ++i) {\n    if (i < len) code = path.charCodeAt(i);\n    else if (isPathSeparator(code!)) break;\n    else code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code!)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += `${separator}..`;\n          else res = \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\n        else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nexport function _format(\n  sep: string,\n  pathObject: FormatInputPathObject,\n): string {\n  const dir: string | undefined = pathObject.dir || pathObject.root;\n  const base: string = pathObject.base ||\n    (pathObject.name || \"\") + (pathObject.ext || \"\");\n  if (!dir) return base;\n  if (dir === pathObject.root) return dir + base;\n  return dir + sep + base;\n}\n\nconst WHITESPACE_ENCODINGS: Record<string, string> = {\n  \"\\u0009\": \"%09\",\n  \"\\u000A\": \"%0A\",\n  \"\\u000B\": \"%0B\",\n  \"\\u000C\": \"%0C\",\n  \"\\u000D\": \"%0D\",\n  \"\\u0020\": \"%20\",\n};\n\nexport function encodeWhitespace(string: string): string {\n  return string.replaceAll(/[\\s]/g, (c) => {\n    return WHITESPACE_ENCODINGS[c] ?? c;\n  });\n}","// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport type { FormatInputPathObject, ParsedPath } from \"./_interface\";\nimport { CHAR_DOT, CHAR_FORWARD_SLASH } from \"./_constants\";\n\nimport {\n  _format,\n  assertPath,\n  encodeWhitespace,\n  isPosixPathSeparator,\n  normalizeString,\n} from \"./_util\";\n\nexport const sep = \"/\";\nexport const delimiter = \":\";\n\n// path.resolve([from ...], to)\n/**\n * Resolves `pathSegments` into an absolute path.\n * @param pathSegments an array of path segments\n */\nexport function resolve(...pathSegments: string[]): string {\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n\n  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    let path: string;\n\n    if (i >= 0) path = pathSegments[i];\n    else {\n      // deno-lint-ignore no-explicit-any\n      const { Deno } = globalThis as any;\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\"Resolved a relative path without a CWD.\");\n      }\n      path = Deno?.cwd?.() ?? \"/\";\n    }\n\n    assertPath(path);\n\n    // Skip empty entries\n    if (path.length === 0) {\n      continue;\n    }\n\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeString(\n    resolvedPath,\n    !resolvedAbsolute,\n    \"/\",\n    isPosixPathSeparator,\n  );\n\n  if (resolvedAbsolute) {\n    if (resolvedPath.length > 0) return `/${resolvedPath}`;\n    else return \"/\";\n  } else if (resolvedPath.length > 0) return resolvedPath;\n  else return \".\";\n}\n\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * @param path to be normalized\n */\nexport function normalize(path: string): string {\n  assertPath(path);\n\n  if (path.length === 0) return \".\";\n\n  const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  const trailingSeparator =\n    path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n  // Normalize the path\n  path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n\n  if (path.length === 0 && !isAbsolute) path = \".\";\n  if (path.length > 0 && trailingSeparator) path += \"/\";\n\n  if (isAbsolute) return `/${path}`;\n  return path;\n}\n\n/**\n * Verifies whether provided path is absolute\n * @param path to be verified as absolute\n */\nexport function isAbsolute(path: string): boolean {\n  assertPath(path);\n  return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n}\n\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n * @param paths to be joined and normalized\n */\nexport function join(...paths: string[]): string {\n  if (paths.length === 0) return \".\";\n  let joined: string | undefined;\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n    assertPath(path);\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `/${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalize(joined);\n}\n\n/**\n * Return the relative path from `from` to `to` based on current working directory.\n * @param from path in current working directory\n * @param to path in current working directory\n */\nexport function relative(from: string, to: string): string {\n  assertPath(from);\n  assertPath(to);\n\n  if (from === to) return \"\";\n\n  from = resolve(from);\n  to = resolve(to);\n\n  if (from === to) return \"\";\n\n  // Trim any leading backslashes\n  let fromStart = 1;\n  const fromEnd = from.length;\n  for (; fromStart < fromEnd; ++fromStart) {\n    if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) break;\n  }\n  const fromLen = fromEnd - fromStart;\n\n  // Trim any leading backslashes\n  let toStart = 1;\n  const toEnd = to.length;\n  for (; toStart < toEnd; ++toStart) {\n    if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) break;\n  }\n  const toLen = toEnd - toStart;\n\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for (; i <= length; ++i) {\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        } else if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (fromCode === CHAR_FORWARD_SLASH) lastCommonSep = i;\n  }\n\n  let out = \"\";\n  // Generate the relative path based on the path difference between `to`\n  // and `from`\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      if (out.length === 0) out += \"..\";\n      else out += \"/..\";\n    }\n  }\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);\n  else {\n    toStart += lastCommonSep;\n    if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) ++toStart;\n    return to.slice(toStart);\n  }\n}\n\n/**\n * Resolves path to a namespace path\n * @param path to resolve to namespace\n */\nexport function toNamespacedPath(path: string): string {\n  // Non-op on posix systems\n  return path;\n}\n\n/**\n * Return the directory name of a `path`.\n * @param path to determine name for\n */\nexport function dirname(path: string): string {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n  const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  let end = -1;\n  let matchedSlash = true;\n  for (let i = path.length - 1; i >= 1; --i) {\n    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? \"/\" : \".\";\n  if (hasRoot && end === 1) return \"//\";\n  return path.slice(0, end);\n}\n\n/**\n * Return the last portion of a `path`. Trailing directory separators are ignored.\n * @param path to process\n * @param ext of path directory\n */\nexport function basename(path: string, ext = \"\"): string {\n  if (ext !== undefined && typeof ext !== \"string\") {\n    throw new TypeError('\"ext\" argument must be a string');\n  }\n  assertPath(path);\n\n  let start = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let i: number;\n\n  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n    if (ext.length === path.length && ext === path) return \"\";\n    let extIdx = ext.length - 1;\n    let firstNonSlashEnd = -1;\n    for (i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          // We saw the first non-path separator, remember this index in case\n          // we need it if the extension ends up not matching\n          matchedSlash = false;\n          firstNonSlashEnd = i + 1;\n        }\n        if (extIdx >= 0) {\n          // Try to match the explicit extension\n          if (code === ext.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              // We matched the extension, so mark this as the end of our path\n              // component\n              end = i;\n            }\n          } else {\n            // Extension does not match, so our result is the entire path\n            // component\n            extIdx = -1;\n            end = firstNonSlashEnd;\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd;\n    else if (end === -1) end = path.length;\n    return path.slice(start, end);\n  } else {\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) return \"\";\n    return path.slice(start, end);\n  }\n}\n\n/**\n * Return the extension of the `path`.\n * @param path with extension\n */\nexport function extname(path: string): string {\n  assertPath(path);\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n  for (let i = path.length - 1; i >= 0; --i) {\n    const code = path.charCodeAt(i);\n    if (code === CHAR_FORWARD_SLASH) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n\n/**\n * Generate a path from `FormatInputPathObject` object.\n * @param pathObject with path\n */\nexport function format(pathObject: FormatInputPathObject): string {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new TypeError(\n      `The \"pathObject\" argument must be of type Object. Received type ${typeof pathObject}`,\n    );\n  }\n  return _format(\"/\", pathObject);\n}\n\n/**\n * Return a `ParsedPath` object of the `path`.\n * @param path to process\n */\nexport function parse(path: string): ParsedPath {\n  assertPath(path);\n\n  const ret: ParsedPath = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n  if (path.length === 0) return ret;\n  const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  let start: number;\n  if (isAbsolute) {\n    ret.root = \"/\";\n    start = 1;\n  } else {\n    start = 0;\n  }\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n\n  // Get non-dir info\n  for (; i >= start; --i) {\n    const code = path.charCodeAt(i);\n    if (code === CHAR_FORWARD_SLASH) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    if (end !== -1) {\n      if (startPart === 0 && isAbsolute) {\n        ret.base = ret.name = path.slice(1, end);\n      } else {\n        ret.base = ret.name = path.slice(startPart, end);\n      }\n    }\n  } else {\n    if (startPart === 0 && isAbsolute) {\n      ret.name = path.slice(1, startDot);\n      ret.base = path.slice(1, end);\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n    }\n    ret.ext = path.slice(startDot, end);\n  }\n\n  if (startPart > 0) ret.dir = path.slice(0, startPart - 1);\n  else if (isAbsolute) ret.dir = \"/\";\n\n  return ret;\n}\n\n/**\n * Converts a file URL to a path string.\n *\n * ```ts\n *      import { fromFileUrl } from \"./posix.ts\";\n *      fromFileUrl(\"file:///home/foo\"); // \"/home/foo\"\n * ```\n * @param url of a file URL\n */\nexport function fromFileUrl(url: string | URL): string {\n  url = url instanceof URL ? url : new URL(url);\n  if (url.protocol != \"file:\") {\n    throw new TypeError(\"Must be a file URL.\");\n  }\n  return decodeURIComponent(\n    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"),\n  );\n}\n\n/**\n * Converts a path string to a file URL.\n *\n * ```ts\n *      import { toFileUrl } from \"./posix.ts\";\n *      toFileUrl(\"/home/foo\"); // new URL(\"file:///home/foo\")\n * ```\n * @param path to convert to file URL\n */\nexport function toFileUrl(path: string): URL {\n  if (!isAbsolute(path)) {\n    throw new TypeError(\"Must be an absolute path.\");\n  }\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(\n    path.replace(/%/g, \"%25\").replace(/\\\\/g, \"%5C\"),\n  );\n  return url;\n}","// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nimport * as _posix from \"./posix\";\nimport { SEP, SEP_PATTERN, type OSType } from \"./_constants\";\n\nconst path = _posix;\nconst { join, normalize } = path;\n\nexport interface GlobOptions {\n  /** Extended glob syntax.\n   * See https://www.linuxjournal.com/content/bash-extended-globbing. Defaults\n   * to true. */\n  extended?: boolean;\n  /** Globstar syntax.\n   * See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n   * If false, `**` is treated like `*`. Defaults to true. */\n  globstar?: boolean;\n  /** Whether globstar should be case insensitive. */\n  caseInsensitive?: boolean;\n  /** Operating system. Defaults to the native OS. */\n  os?: OSType;\n}\n\nexport type GlobToRegExpOptions = GlobOptions;\n\nconst regExpEscapeChars = [\n  \"!\",\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"=\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"^\",\n  \"{\",\n  \"|\",\n];\nconst rangeEscapeChars = [\"-\", \"\\\\\", \"]\"];\n\n/** Convert a glob string to a regular expression.\n *\n * Tries to match bash glob expansion as closely as possible.\n *\n * Basic glob syntax:\n * - `*` - Matches everything without leaving the path segment.\n * - `?` - Matches any single character.\n * - `{foo,bar}` - Matches `foo` or `bar`.\n * - `[abcd]` - Matches `a`, `b`, `c` or `d`.\n * - `[a-d]` - Matches `a`, `b`, `c` or `d`.\n * - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.\n * - `[[:<class>:]]` - Matches any character belonging to `<class>`.\n *     - `[[:alnum:]]` - Matches any digit or letter.\n *     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.\n *     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes\n *       for a complete list of supported character classes.\n * - `\\` - Escapes the next character for an `os` other than `\"windows\"`.\n * - \\` - Escapes the next character for `os` set to `\"windows\"`.\n * - `/` - Path separator.\n * - `\\` - Additional path separator only for `os` set to `\"windows\"`.\n *\n * Extended syntax:\n * - Requires `{ extended: true }`.\n * - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.\n * - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.\n * - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.\n * - `+(foo|bar)` - Matches _n > 0_ instances of `{foo,bar}`.\n * - `!(foo|bar)` - Matches anything other than `{foo,bar}`.\n * - See https://www.linuxjournal.com/content/bash-extended-globbing.\n *\n * Globstar syntax:\n * - Requires `{ globstar: true }`.\n * - `**` - Matches any number of any path segments.\n *     - Must comprise its entire path segment in the provided glob.\n * - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n *\n * Note the following properties:\n * - The generated `RegExp` is anchored at both start and end.\n * - Repeating and trailing separators are tolerated. Trailing separators in the\n *   provided glob have no meaning and are discarded.\n * - Absolute globs will only match absolute paths, etc.\n * - Empty globs will match nothing.\n * - Any special glob syntax must be contained to one path segment. For example,\n *   `?(foo|bar/baz)` is invalid. The separator will take precedence and the\n *   first segment ends with an unclosed group.\n * - If a path segment ends with unclosed groups or a dangling escape prefix, a\n *   parse error has occurred. Every character for that segment is taken\n *   literally in this event.\n *\n * Limitations:\n * - A negative group like `!(foo|bar)` will wrongly be converted to a negative\n *   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly\n *   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,\n *   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if\n *   the group occurs not nested at the end of the segment. */\nexport function globToRegExp(\n  glob: string,\n  {\n    extended = true,\n    globstar: globstarOption = true,\n    os = \"linux\",\n    caseInsensitive = false,\n  }: GlobToRegExpOptions = {},\n): RegExp {\n  if (glob == \"\") {\n    return /(?!)/;\n  }\n\n  const sep = os == \"windows\" ? \"(?:\\\\\\\\|/)+\" : \"/+\";\n  const sepMaybe = os == \"windows\" ? \"(?:\\\\\\\\|/)*\" : \"/*\";\n  const seps = os == \"windows\" ? [\"\\\\\", \"/\"] : [\"/\"];\n  const globstar = os == \"windows\"\n    ? \"(?:[^\\\\\\\\/]*(?:\\\\\\\\|/|$)+)*\"\n    : \"(?:[^/]*(?:/|$)+)*\";\n  const wildcard = os == \"windows\" ? \"[^\\\\\\\\/]*\" : \"[^/]*\";\n  const escapePrefix = os == \"windows\" ? \"`\" : \"\\\\\";\n\n  // Remove trailing separators.\n  let newLength = glob.length;\n  for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);\n  glob = glob.slice(0, newLength);\n\n  let regExpString = \"\";\n\n  // Terminates correctly. Trust that `j` is incremented every iteration.\n  for (let j = 0; j < glob.length;) {\n    let segment = \"\";\n    const groupStack: string[] = [];\n    let inRange = false;\n    let inEscape = false;\n    let endsWithSep = false;\n    let i = j;\n\n    // Terminates with `i` at the non-inclusive end of the current segment.\n    for (; i < glob.length && !seps.includes(glob[i]); i++) {\n      if (inEscape) {\n        inEscape = false;\n        const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;\n        segment += escapeChars.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n        continue;\n      }\n\n      if (glob[i] == escapePrefix) {\n        inEscape = true;\n        continue;\n      }\n\n      if (glob[i] == \"[\") {\n        if (!inRange) {\n          inRange = true;\n          segment += \"[\";\n          if (glob[i + 1] == \"!\") {\n            i++;\n            segment += \"^\";\n          } else if (glob[i + 1] == \"^\") {\n            i++;\n            segment += \"\\\\^\";\n          }\n          continue;\n        } else if (glob[i + 1] == \":\") {\n          let k = i + 1;\n          let value = \"\";\n          while (glob[k + 1] != null && glob[k + 1] != \":\") {\n            value += glob[k + 1];\n            k++;\n          }\n          if (glob[k + 1] == \":\" && glob[k + 2] == \"]\") {\n            i = k + 2;\n            if (value == \"alnum\") segment += \"\\\\dA-Za-z\";\n            else if (value == \"alpha\") segment += \"A-Za-z\";\n            else if (value == \"ascii\") segment += \"\\x00-\\x7F\";\n            else if (value == \"blank\") segment += \"\\t \";\n            else if (value == \"cntrl\") segment += \"\\x00-\\x1F\\x7F\";\n            else if (value == \"digit\") segment += \"\\\\d\";\n            else if (value == \"graph\") segment += \"\\x21-\\x7E\";\n            else if (value == \"lower\") segment += \"a-z\";\n            else if (value == \"print\") segment += \"\\x20-\\x7E\";\n            else if (value == \"punct\") {\n              segment += \"!\\\"#$%&'()*+,\\\\-./:;<=>?@[\\\\\\\\\\\\]^_‘{|}~\";\n            } else if (value == \"space\") segment += \"\\\\s\\v\";\n            else if (value == \"upper\") segment += \"A-Z\";\n            else if (value == \"word\") segment += \"\\\\w\";\n            else if (value == \"xdigit\") segment += \"\\\\dA-Fa-f\";\n            continue;\n          }\n        }\n      }\n\n      if (glob[i] == \"]\" && inRange) {\n        inRange = false;\n        segment += \"]\";\n        continue;\n      }\n\n      if (inRange) {\n        if (glob[i] == \"\\\\\") {\n          segment += `\\\\\\\\`;\n        } else {\n          segment += glob[i];\n        }\n        continue;\n      }\n\n      if (\n        glob[i] == \")\" && groupStack.length > 0 &&\n        groupStack[groupStack.length - 1] != \"BRACE\"\n      ) {\n        segment += \")\";\n        const type = groupStack.pop()!;\n        if (type == \"!\") {\n          segment += wildcard;\n        } else if (type != \"@\") {\n          segment += type;\n        }\n        continue;\n      }\n\n      if (\n        glob[i] == \"|\" && groupStack.length > 0 &&\n        groupStack[groupStack.length - 1] != \"BRACE\"\n      ) {\n        segment += \"|\";\n        continue;\n      }\n\n      if (glob[i] == \"+\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"+\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"@\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"@\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"?\") {\n        if (extended && glob[i + 1] == \"(\") {\n          i++;\n          groupStack.push(\"?\");\n          segment += \"(?:\";\n        } else {\n          segment += \".\";\n        }\n        continue;\n      }\n\n      if (glob[i] == \"!\" && extended && glob[i + 1] == \"(\") {\n        i++;\n        groupStack.push(\"!\");\n        segment += \"(?!\";\n        continue;\n      }\n\n      if (glob[i] == \"{\") {\n        groupStack.push(\"BRACE\");\n        segment += \"(?:\";\n        continue;\n      }\n\n      if (glob[i] == \"}\" && groupStack[groupStack.length - 1] == \"BRACE\") {\n        groupStack.pop();\n        segment += \")\";\n        continue;\n      }\n\n      if (glob[i] == \",\" && groupStack[groupStack.length - 1] == \"BRACE\") {\n        segment += \"|\";\n        continue;\n      }\n\n      if (glob[i] == \"*\") {\n        if (extended && glob[i + 1] == \"(\") {\n          i++;\n          groupStack.push(\"*\");\n          segment += \"(?:\";\n        } else {\n          const prevChar = glob[i - 1];\n          let numStars = 1;\n          while (glob[i + 1] == \"*\") {\n            i++;\n            numStars++;\n          }\n          const nextChar = glob[i + 1];\n          if (\n            globstarOption && numStars == 2 &&\n            [...seps, undefined].includes(prevChar) &&\n            [...seps, undefined].includes(nextChar)\n          ) {\n            segment += globstar;\n            endsWithSep = true;\n          } else {\n            segment += wildcard;\n          }\n        }\n        continue;\n      }\n\n      segment += regExpEscapeChars.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n    }\n\n    // Check for unclosed groups or a dangling backslash.\n    if (groupStack.length > 0 || inRange || inEscape) {\n      // Parse failure. Take all characters from this segment literally.\n      segment = \"\";\n      for (const c of glob.slice(j, i)) {\n        segment += regExpEscapeChars.includes(c) ? `\\\\${c}` : c;\n        endsWithSep = false;\n      }\n    }\n\n    regExpString += segment;\n    if (!endsWithSep) {\n      regExpString += i < glob.length ? sep : sepMaybe;\n      endsWithSep = true;\n    }\n\n    // Terminates with `i` at the start of the next segment.\n    while (seps.includes(glob[i])) i++;\n\n    // Check that the next value of `j` is indeed higher than the current value.\n    if (!(i > j)) {\n      throw new Error(\"Assertion failure: i > j (potential infinite loop)\");\n    }\n    j = i;\n  }\n\n  regExpString = `^${regExpString}$`;\n  return new RegExp(regExpString, caseInsensitive ? \"i\" : \"\");\n}\n\n/** Test whether the given string is a glob */\nexport function isGlob(str: string): boolean {\n  const chars: Record<string, string> = { \"{\": \"}\", \"(\": \")\", \"[\": \"]\" };\n  const regex =\n    /\\\\(.)|(^!|\\*|\\?|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\n\n  if (str === \"\") {\n    return false;\n  }\n\n  let match: RegExpExecArray | null;\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    let idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    const open = match[1];\n    const close = open ? chars[open] : null;\n    if (open && close) {\n      const n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n\n  return false;\n}\n\n/** Like normalize(), but doesn't collapse \"**\\/..\" when `globstar` is true. */\nexport function normalizeGlob(\n  glob: string,\n  { globstar = false }: GlobOptions = {},\n): string {\n  if (glob.match(/\\0/g)) {\n    throw new Error(`Glob contains invalid characters: \"${glob}\"`);\n  }\n  if (!globstar) {\n    return normalize(glob);\n  }\n  const s = SEP_PATTERN.source;\n  const badParentPattern = new RegExp(\n    `(?<=(${s}|^)\\\\*\\\\*${s})\\\\.\\\\.(?=${s}|$)`,\n    \"g\",\n  );\n  return normalize(glob.replace(badParentPattern, \"\\0\")).replace(/\\0/g, \"..\");\n}\n\n/** Like join(), but doesn't collapse \"**\\/..\" when `globstar` is true. */\nexport function joinGlobs(\n  globs: string[],\n  { extended = true, globstar = false }: GlobOptions = {},\n): string {\n  if (!globstar || globs.length == 0) {\n    return join(...globs);\n  }\n  if (globs.length === 0) return \".\";\n  let joined: string | undefined;\n  for (const glob of globs) {\n    const path = glob;\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `${SEP}${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalizeGlob(joined, { extended, globstar });\n}\n","// https://deno.land/std@0.142.0/path/mod.ts\n// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n\n/**\n * Ported mostly from https://github.com/browserify/path-browserify/\n * This module is browser compatible.\n * @module\n */\n\nimport * as _posix from \"./posix\";\n\nconst path = _posix;\nexport const posix = _posix;\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  fromFileUrl,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  relative,\n  resolve,\n  sep,\n  toFileUrl,\n  toNamespacedPath,\n} = path;\n\nexport { SEP, SEP_PATTERN } from \"./_constants\";\nexport * from \"./_interface\";\nexport * from \"./glob\";","import { isAbsolute, join } from \"../deno/path/mod\";\nimport { encodeWhitespace } from \"../deno/path/_util\";\n\nexport * from \"../deno/path/mod\";\n\n/** \n * Based on https://github.com/egoist/play-esbuild/blob/main/src/lib/path.ts#L123\n * \n * Support joining paths to a URL\n */\nexport const urlJoin = (urlStr: string, ...args: string[]) => {\n  const url = new URL(urlStr);\n  url.pathname = encodeWhitespace(\n    join(url.pathname, ...args).replace(/%/g, \"%25\").replace(/\\\\/g, \"%5C\"),\n  );\n  return url.toString();\n}\n\n/**\n * An import counts as a bare import if it's neither a relative import of an absolute import\n */\nexport const isBareImport = (importStr: string) => {\n  return /^(?!\\.).*/.test(importStr) && !isAbsolute(importStr);\n}","import type { Loader } from 'esbuild-wasm';\nimport { extname } from './path';\n\n/** Based on https://github.com/egoist/play-esbuild/blob/main/src/lib/esbuild.ts */\nexport const RESOLVE_EXTENSIONS = [\".tsx\", \".ts\", \".jsx\", \".js\", \".css\", \".json\"];\n\n/**\n * Based on the file extention determine the esbuild loader to use\n */\nexport const inferLoader = (urlStr: string): Loader => {\n  const ext = extname(urlStr);\n  if (RESOLVE_EXTENSIONS.includes(ext))\n    // Resolve all .js and .jsx files to .ts and .tsx files\n    return (/\\.js(x)?$/.test(ext) ? ext.replace(/^\\.js/, \".ts\") : ext).slice(1) as Loader;\n\n  if (ext === \".mjs\" || ext === \".cjs\") return \"ts\"; // \"js\"\n  if (ext === \".mts\" || ext === \".cts\") return \"ts\";\n\n  if (ext == \".scss\") return \"css\";\n\n  if (ext == \".png\" || ext == \".jpeg\" || ext == \".ttf\") return \"dataurl\";\n  if (ext == \".svg\" || ext == \".html\" || ext == \".txt\") return \"text\";\n  if (ext == \".wasm\") return \"file\";\n\n  return ext.length ? \"text\" : \"ts\";\n}","/** \n * Based on `resolve.exports` (https://npmjs.com/resolve.exports) by lukeed (https://github.com/lukeed)\n */\n\n/**\n * @param {object} exports\n * @param {Set<string>} keys\n */\nexport function loop(exports: Record<any, any>, keys: Set<string>) {\n\tif (typeof exports === 'string') {\n\t\treturn exports;\n\t}\n\n\tif (exports) {\n\t\tlet idx, tmp;\n\t\tif (Array.isArray(exports)) {\n\t\t\tfor (idx = 0; idx < exports.length; idx++) {\n\t\t\t\tif (tmp = loop(exports[idx], keys)) return tmp;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (idx in exports) {\n\t\t\t\tif (keys.has(idx)) {\n\t\t\t\t\treturn loop(exports[idx], keys);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {string} name The package name\n * @param {string} entry The target entry, eg \".\"\n * @param {number} [condition] Unmatched condition?\n */\nexport function bail(name: string, entry: string, condition?: number) {\n\tthrow new Error(\n\t\tcondition\n\t\t\t? `No known conditions for \"${entry}\" entry in \"${name}\" package`\n\t\t\t: `Missing \"${entry}\" export in \"${name}\" package`\n\t);\n}\n\n/**\n * @param {string} name the package name\n * @param {string} entry the target path/import\n */\nexport function toName(name: string, entry: string) {\n\treturn entry === name ? '.'\n\t\t: entry[0] === '.' ? entry\n\t\t\t: entry.replace(new RegExp('^' + name + '\\/'), './');\n}\n\n\nexport type Options = {\n\tbrowser?: boolean;\n\tconditions?: readonly string[];\n\trequire?: boolean;\n\tunsafe?: false;\n} | {\n\tconditions?: readonly string[];\n\tunsafe?: true;\n}\n\n/**\n * @param {object} pkg package.json contents\n * @param {string} [entry] entry name or import path\n * @param {object} [options]\n * @param {boolean} [options.browser]\n * @param {boolean} [options.require]\n * @param {string[]} [options.conditions]\n * @param {boolean} [options.unsafe]\n */\nexport function resolveExports<T = Record<any, any>>(pkg: T, entry = '.', options: Options = {}): string | void {\n\tlet { name, exports } = pkg as unknown as Record<any, any>;\n\n\tif (exports) {\n\t\t// @ts-ignore\n\t\tlet { browser, require, unsafe, conditions = [] } = options;\n\n\t\tlet target = toName(name, entry);\n\t\tif (target[0] !== '.') target = './' + target;\n\n\t\tif (typeof exports === 'string') {\n\t\t\treturn target === '.' ? exports : bail(name, target);\n\t\t}\n\n\t\tlet allows = new Set(['default', ...conditions]);\n\t\tunsafe || allows.add(require ? 'require' : 'import');\n\t\tunsafe || allows.add(browser ? 'browser' : 'node');\n\n\t\tlet key, tmp, isSingle = false;\n\n\t\tfor (key in exports) {\n\t\t\tisSingle = key[0] !== '.';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (isSingle) {\n\t\t\treturn target === '.'\n\t\t\t\t? loop(exports, allows) || bail(name, target, 1)\n\t\t\t\t: bail(name, target);\n\t\t}\n\n\t\tif (tmp = exports[target]) {\n\t\t\treturn loop(tmp, allows) || bail(name, target, 1);\n\t\t}\n\n\t\tfor (key in exports) {\n\t\t\ttmp = key[key.length - 1];\n\t\t\tif (tmp === '/' && target.startsWith(key)) {\n\t\t\t\treturn (tmp = loop(exports[key], allows))\n\t\t\t\t\t? (tmp + target.substring(key.length))\n\t\t\t\t\t: bail(name, target, 1);\n\t\t\t}\n\t\t\tif (tmp === '*' && target.startsWith(key.slice(0, -1))) {\n\t\t\t\t// do not trigger if no *content* to inject\n\t\t\t\tif (target.substring(key.length - 1).length > 0) {\n\t\t\t\t\treturn (tmp = loop(exports[key], allows))\n\t\t\t\t\t\t? tmp.replace('*', target.substring(key.length - 1))\n\t\t\t\t\t\t: bail(name, target, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn bail(name, target);\n\t}\n}\n\nexport type BrowserFiles = Record<string, string | false>;\n\n/**\n * @param {object} pkg\n * @param {object} [options]\n * @param {string|boolean} [options.browser]\n * @param {string[]} [options.fields]\n */\nexport function legacy<T = Record<any, any>>(pkg: T, options?: { browser: true, fields?: string[] }): BrowserFiles | string | void;\nexport function legacy<T = Record<any, any>>(pkg: T, options?: { browser: string, fields?: string[] }): string | false | void;\nexport function legacy<T = Record<any, any>>(pkg: T, options?: { browser: false, fields?: string[] }): string | void;\nexport function legacy<T = Record<any, any>>(pkg: T, options: {\n\tbrowser?: boolean | string;\n\tfields?: string[];\n} = {}): BrowserFiles | string | false | void {\n\tlet i = 0, value,\n\t\tbrowser = options.browser,\n\t\tfields = options.fields || ['module', 'main'];\n\n\tif (browser && !fields.includes('browser')) {\n\t\tfields.unshift('browser');\n\t}\n\n\tfor (; i < fields.length; i++) {\n\t\tif (value = pkg[fields[i]]) {\n\t\t\tif (typeof value == 'string') {\n\t\t\t\t//\n\t\t\t} else if (typeof value == 'object' && fields[i] == 'browser') {\n\t\t\t\tif (typeof browser == 'string') {\n\t\t\t\t\tvalue = value[browser = toName((pkg as unknown as { name: string }).name, browser)];\n\t\t\t\t\tif (value == null) return browser;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn typeof value == 'string'\n\t\t\t\t? ('./' + value.replace(/^\\.?\\//, ''))\n\t\t\t\t: value;\n\t\t}\n\t}\n}","/** \n * Based on `parse-package-name` (https://npmjs.com/parse-package-name) by @egoist (https://github.com/egoist) \n */\n\n/** Parsed a scoped package name into name, version, and path. */\nexport const RE_SCOPED = /^(@[^\\/]+\\/[^@\\/]+)(?:@([^\\/]+))?(\\/.*)?$/;\n\n/** Parsed a non-scoped package name into name, version, path */\nexport const RE_NON_SCOPED = /^([^@\\/]+)(?:@([^\\/]+))?(\\/.*)?$/;\n\nexport function parsePackageName(input: string) {\n  const m = RE_SCOPED.exec(input) || RE_NON_SCOPED.exec(input)\n\n  if (!m) {\n    throw new Error(`[parse-package-name] invalid package name: ${input}`)\n  }\n\n  return {\n    name: m[1] || '',\n    version: m[2] || 'latest',\n    path: m[3] || '',\n  }\n}\n\nexport default parsePackageName;","/** \n * Based on `resolve.exports` (https://npmjs.com/resolve.exports) by @lukeed (https://github.com/lukeed), but tweaked to work for imports\n */\nimport { toName, bail, loop } from \"./resolve-exports\";\n\nexport interface ResolveImportOptions { \n\tbrowser?: boolean;\n\trequire?: boolean;\n\tconditions?: string[];\n\tunsafe?: boolean;\n}\n\n/**\n * @param {object} pkg package.json contents\n * @param {string} [entry] entry name or import path\n * @param {object} [options]\n * @param {boolean} [options.browser]\n * @param {boolean} [options.require]\n * @param {string[]} [options.conditions]\n * @param {boolean} [options.unsafe]\n */\nexport function resolveImports(pkg: Record<any, any>, entry = '.', options: ResolveImportOptions = {}) {\n\tlet { name, imports } = pkg;\n\n\tif (imports) {\n\t\tlet { browser, require, unsafe, conditions = [] } = options;\n\n\t\tlet target = toName(name, entry);\n\t\t// if (target[0] !== '.') target = './' + target;\n\n\t\tif (typeof imports === 'string') {\n\t\t\treturn target === '#' ? imports : bail(name, target);\n\t\t}\n\n\t\tlet allows = new Set(['default', ...conditions]);\n\t\tunsafe || allows.add(require ? 'require' : 'import');\n\t\tunsafe || allows.add(browser ? 'browser' : 'node');\n\n\t\tlet key, tmp, isSingle = false;\n\n\t\tfor (key in imports) {\n\t\t\tisSingle = key[0] !== '#';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (isSingle) {\n\t\t\treturn target === '#'\n\t\t\t\t? loop(imports, allows) || bail(name, target, 1)\n\t\t\t\t: bail(name, target);\n\t\t}\n\n\t\tif (tmp = imports[target]) {\n\t\t\treturn loop(tmp, allows) || bail(name, target, 1);\n\t\t}\n\n\t\tfor (key in imports) {\n\t\t\ttmp = key[key.length - 1];\n\t\t\tif (tmp === '/' && target.startsWith(key)) {\n\t\t\t\treturn (tmp = loop(imports[key], allows))\n\t\t\t\t\t? (tmp + target.substring(key.length))\n\t\t\t\t\t: bail(name, target, 1);\n\t\t\t}\n\t\t\tif (tmp === '*' && target.startsWith(key.slice(0, -1))) {\n\t\t\t\t// do not trigger if no *content* to inject\n\t\t\t\tif (target.substring(key.length - 1).length > 0) {\n\t\t\t\t\treturn (tmp = loop(imports[key], allows))\n\t\t\t\t\t\t? tmp.replace('*', target.substring(key.length - 1))\n\t\t\t\t\t\t: bail(name, target, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn bail(name, target);\n\t}\n}","import type { OnResolveArgs, OnResolveResult, Plugin } from 'esbuild-wasm';\nimport type { BundleConfigOptions } from '../configs/options';\nimport type { EVENTS } from '../configs/events';\nimport type { STATE } from '../configs/state';\n\nimport { resolveExports, legacy } from \"../utils/resolve-exports\";\nimport { parsePackageName as parsePackageName } from \"../utils/parse-package-name\";\n\nimport { HTTP_NAMESPACE } from './http';\n\nimport { isBareImport } from '../utils/path';\nimport { getRequest } from '../utils/fetch-and-cache';\n\nimport { getCDNUrl, getCDNStyle } from '../utils/util-cdn';\nimport { resolveImports } from '../utils/resolve-imports';\nimport { DEFAULT_CDN_HOST } from '../utils/util-cdn';\n\n/** CDN Plugin Namespace */\nexport const CDN_NAMESPACE = 'cdn-url';\n\n/**\n * Resolution algorithm for the esbuild CDN plugin \n * \n * @param cdn The default CDN to use\n * @param logger Console log\n */\nexport const CDN_RESOLVE = (cdn = DEFAULT_CDN_HOST, events: typeof EVENTS) => {\n  return async (args: OnResolveArgs): Promise<OnResolveResult> => {\n    if (isBareImport(args.path)) {\n      // Support a different default CDN + allow for custom CDN url schemes\n      let { path: argPath, origin } = getCDNUrl(args.path, cdn);\n\n      // npm standard CDNs, e.g. unpkg, skypack, esm.sh, etc...\n      let NPM_CDN = getCDNStyle(origin) == \"npm\";\n\n      // Heavily based off of https://github.com/egoist/play-esbuild/blob/main/src/lib/esbuild.ts\n      let parsed = parsePackageName(argPath);\n      let subpath = parsed.path;\n      let pkg = args.pluginData?.pkg ?? {};\n\n      // Resolving imports from the package.json, if said import starts with \"#\" \n      // If an import starts with \"#\" then it's a subpath-import\n      // https://nodejs.org/api/packages.html#subpath-imports\n      if (argPath[0] == \"#\") {\n        let path = resolveImports({ ...pkg, exports: pkg.imports }, argPath, {\n          require: args.kind === \"require-call\" || args.kind === \"require-resolve\"\n        });\n\n        if (typeof path === \"string\") {\n          subpath = path.replace(/^\\.?\\/?/, \"/\");\n\n          if (subpath && subpath[0] !== \"/\")\n            subpath = `/${subpath}`;\n\n          let version = NPM_CDN ? \"@\" + pkg.version : \"\";\n          let { url: { href } } = getCDNUrl(`${pkg.name}${version}${subpath}`);\n          return {\n            namespace: HTTP_NAMESPACE,\n            path: href,\n            pluginData: { pkg }\n          };\n        }\n      }\n\n      // Are there an dependecies???? Well Goood.\n      let depsExists = \"dependencies\" in pkg || \"devDependencies\" in pkg || \"peerDependencies\" in pkg;\n      if (depsExists && !/\\S+@\\S+/.test(argPath)) {\n        let {\n          devDependencies = {},\n          dependencies = {},\n          peerDependencies = {}\n        } = pkg;\n\n        let deps = Object.assign({}, devDependencies, peerDependencies, dependencies);\n        let keys = Object.keys(deps);\n\n        if (keys.includes(argPath))\n          parsed.version = deps[argPath];\n      }\n\n      // If the CDN supports package.json and some other npm stuff, it counts as an npm CDN\n      if (NPM_CDN) {\n        try {\n          let { url: PACKAGE_JSON_URL } = getCDNUrl(`${parsed.name}@${parsed.version}/package.json`, origin);\n\n          // Strongly cache package.json files\n          pkg = await getRequest(PACKAGE_JSON_URL, true).then((res) => res.json());\n          let path = resolveExports(pkg, subpath ? \".\" + subpath.replace(/^\\.?\\/?/, \"/\") : \".\", {\n            require: args.kind === \"require-call\" || args.kind === \"require-resolve\",\n          }) || legacy(pkg);\n\n          if (typeof path === \"string\")\n            subpath = path.replace(/^\\.?\\/?/, \"/\").replace(/\\.js\\.js$/, \".js\");\n\n          if (subpath && subpath[0] !== \"/\")\n            subpath = `/${subpath}`;\n        } catch (e) {\n          events\n            .emit(\n              \"logger.warn\",\n              `You may want to change CDNs. The current CDN ${!/unpkg\\.com/.test(origin) ? `\"${origin}\" doesn't` : `path \"${origin}${argPath}\" may not`} support package.json files.\\nThere is a chance the CDN you're using doesn't support looking through the package.json of packages. bundlejs will switch to inaccurate guesses for package versions. For package.json support you may wish to use https://unpkg.com or other CDN's that support package.json.`\n            )\n            .emit(\"logger.warn\", e);\n        }\n      }\n\n      // If the CDN is npm based then it should add the parsed version to the URL\n      // e.g. https://unpkg.com/spring-easing@v1.0.0/\n      let version = NPM_CDN ? \"@\" + parsed.version : \"\";\n      let { url } = getCDNUrl(`${parsed.name}${version}${subpath}`, origin);\n      return {\n        namespace: HTTP_NAMESPACE,\n        path: url.toString(),\n        pluginData: { pkg }\n      };\n    }\n  };\n};\n\n/**\n * Esbuild CDN plugin \n * \n * @param cdn The default CDN to use\n * @param logger Console log\n */\nexport const CDN = (events: typeof EVENTS, state: typeof STATE, config: BundleConfigOptions): Plugin => {\n  // Convert CDN values to URL origins\n  let { origin: cdn } = !/:/.test(config?.cdn) ? getCDNUrl(config?.cdn + \":\") : getCDNUrl(config?.cdn);\n  const FileSystem = config.filesystem; \n  return {\n    name: CDN_NAMESPACE,\n    setup(build) {\n      // Resolve bare imports to the CDN required using different URL schemes\n      build.onResolve({ filter: /.*/ }, CDN_RESOLVE(cdn, events));\n      build.onResolve({ filter: /.*/, namespace: CDN_NAMESPACE }, CDN_RESOLVE(cdn, events));\n    },\n  };\n};\n","/** Based on https://github.com/hardfist/neo-tools/blob/main/packages/bundler/src/plugins/http.ts */\nimport type { OnResolveArgs, OnResolveResult, Plugin } from 'esbuild-wasm';\nimport type { BundleConfigOptions } from '../configs/options';\nimport type { EVENTS } from '../configs/events';\nimport type { STATE } from '../configs/state';\n\nimport { getRequest } from '../utils/fetch-and-cache';\nimport { decode } from '../utils/encode-decode';\n\nimport { getCDNUrl, DEFAULT_CDN_HOST, getCDNStyle } from '../utils/util-cdn';\nimport { inferLoader } from '../utils/loader';\n\nimport { urlJoin, extname, isBareImport } from \"../utils/path\";\nimport { CDN_RESOLVE } from './cdn';\n\n/** HTTP Plugin Namespace */\nexport const HTTP_NAMESPACE = 'http-url';\n\n/**\n * Fetches packages\n * \n * @param url package url to fetch\n * @param logger Console log\n */\nexport const fetchPkg = async (url: string, events: typeof EVENTS) => {\n  try {\n    let response = await getRequest(url);\n    if (!response.ok)\n      throw new Error(`Couldn't load ${response.url} (${response.status} code)`);\n\n    events.emit(\"logger.info\", `Fetch ${url}`);\n\n    return {\n      url: response.url,\n      content: new Uint8Array(await response.arrayBuffer()),\n    };\n  } catch (err) {\n    throw new Error(`[getRequest] Failed at request (${url})\\n${err.toString()}`);\n  }\n};\n\n/**\n * Fetches assets from a js file, e.g. assets like WASM, Workers, etc... \n * External assets are referenced using this syntax, e.g. new URL(\"...\", import.meta.url)\n * Any external assets found inside said original js file, are fetched and stored\n * \n * @param path Path for original js files \n * @param content Content of original js files\n * @param namespace esbuild plugin namespace\n * @param logger Console log\n */\nexport const fetchAssets = async (path: string, content: Uint8Array, namespace: string, events: typeof EVENTS, config: BundleConfigOptions) => {\n  const rgx = /new URL\\(['\"`](.*)['\"`],(?:\\s+)?import\\.meta\\.url(?:\\s+)?\\)/g;\n  const parentURL = new URL(\"./\", path).toString();\n  const FileSystem = config.filesystem; \n\n  const code = decode(content);\n  const matches = Array.from(code.matchAll(rgx)) as RegExpMatchArray[];\n\n  const promises = matches.map(async ([, assetURL]) => {\n    let { content: asset, url } = await fetchPkg(urlJoin(parentURL, assetURL), events);\n\n    // Create a virtual file system for storing assets\n    // This is for building a package bundle analyzer \n    FileSystem.set(namespace + \":\" + url, content);\n\n    return {\n      path: assetURL, contents: asset,\n      get text() { return decode(asset); }\n    };\n  });\n\n  return await Promise.allSettled(promises);\n};\n\n/**\n * Resolution algorithm for the esbuild HTTP plugin\n * \n * @param host The default host origin to use if an import doesn't already have one\n * @param logger Console log\n */\nexport const HTTP_RESOLVE = (host = DEFAULT_CDN_HOST, events: typeof EVENTS) => {\n  return async (args: OnResolveArgs): Promise<OnResolveResult> => {\n    // Some packages use \"../../\" with the assumption that \"/\" is equal to \"/index.js\", this is supposed to fix that bug\n    let argPath = args.path.replace(/\\/$/, \"/index\");\n\n    // If the import path isn't relative do this...\n    if (!argPath.startsWith(\".\")) {\n      // If the import is an http import load the content via the http plugins loader\n      if (/^https?:\\/\\//.test(argPath)) {\n        return {\n          path: argPath,\n          namespace: HTTP_NAMESPACE,\n          pluginData: { pkg: args.pluginData?.pkg },\n        };\n      }\n\n      let pathOrigin = new URL(\n        // Use the parent files URL as a host\n        urlJoin(args.pluginData?.url ? args.pluginData?.url : host, \"../\", argPath)\n      ).origin;\n\n      // npm standard CDNs, e.g. unpkg, skypack, esm.sh, etc...\n      let NPM_CDN = getCDNStyle(pathOrigin) == \"npm\";\n      let origin = NPM_CDN ? pathOrigin : host;\n\n      // If the import is a bare import, use the CDN plugins resolution algorithm\n      if (isBareImport(argPath)) {\n        return CDN_RESOLVE(origin, events)(args);\n      } else {\n        /** \n         * If the import is neither an http import or a bare import (module import), then it is an absolute import.\n         * Therefore, load the content via the http plugins loader, but make sure that the absolute URL doesn't go past the root URL\n         * \n         * e.g. \n         * To load `jquery` from jsdelivr, the CDN root needs to `https://cdn.jsdelivr.net/npm`, \n         * thus the final URL is https://cdn.jsdelivr.net/npm/jquery\n         * \n         * The problem is that if a user using absolute URL's aims for the root domain, \n         * the result should be `https://cdn.jsdelivr.net`, but what we really want is for our use case is\n         * a root of `https://cdn.jsdelivr.net/npm`\n         * \n         * So, we treat the path as a CDN and force all URLs to use CDN origins as the root domain\n        */\n        return {\n          path: getCDNUrl(argPath, origin).url.toString(),\n          namespace: HTTP_NAMESPACE,\n          pluginData: { pkg: args.pluginData?.pkg },\n        };\n      }\n    }\n\n    // For relative imports\n    let path = urlJoin(args.pluginData?.url, \"../\", argPath);\n    return {\n      path,\n      namespace: HTTP_NAMESPACE,\n      pluginData: { pkg: args.pluginData?.pkg },\n    };\n  };\n};\n\n/**\n * Esbuild HTTP plugin \n * \n * @param assets Array to store fetched assets\n * @param host The default host origin to use if an import doesn't already have one\n * @param logger Console log\n */\nexport const HTTP = (events: typeof EVENTS, state: typeof STATE, config: BundleConfigOptions): Plugin => {\n  // Convert CDN values to URL origins\n  let { origin: host } = !/:/.test(config?.cdn) ? getCDNUrl(config?.cdn + \":\") : getCDNUrl(config?.cdn);\n  const FileSystem = config.filesystem;\n  const assets = state.assets ?? [];\n  return {\n    name: HTTP_NAMESPACE,\n    setup(build) {\n      // Intercept import paths starting with \"http:\" and \"https:\" so\n      // esbuild doesn't attempt to map them to a file system location.\n      // Tag them with the \"http-url\" namespace to associate them with\n      // this plugin.\n      build.onResolve({ filter: /^https?:\\/\\// }, args => {\n        return {\n          path: args.path,\n          namespace: HTTP_NAMESPACE,\n        };\n      });\n\n      // We also want to intercept all import paths inside downloaded\n      // files and resolve them against the original URL. All of these\n      // files will be in the \"http-url\" namespace. Make sure to keep\n      // the newly resolved URL in the \"http-url\" namespace so imports\n      // inside it will also be resolved as URLs recursively.\n      build.onResolve({ filter: /.*/, namespace: HTTP_NAMESPACE }, HTTP_RESOLVE(host, events));\n\n      // When a URL is loaded, we want to actually download the content\n      // from the internet. This has just enough logic to be able to\n      // handle the example import from https://cdn.esm.sh/ but in reality this\n      // would probably need to be more complex.\n      build.onLoad({ filter: /.*/, namespace: HTTP_NAMESPACE }, async (args) => {\n        // Some typescript files don't have file extensions but you can't fetch a file without their file extension\n        // so bundle tries to solve for that\n        let ext = extname(args.path);\n        let argPath = (suffix = \"\") => ext.length > 0 ? args.path : args.path + suffix;\n        let content: Uint8Array, url: string;\n\n        try {\n          // Fetch the path without the `.ts` extension\n          ({ content, url } = await fetchPkg(argPath(), events));\n        } catch (err) {\n          // If the ^ above fetch doesn't work, try again with a `.ts` extension\n          // Some typescript files don't have file extensions but you can't fetch a file without their file extension\n          try {\n            ({ content, url } = await fetchPkg(argPath(\".ts\"), events));\n          } catch (e) {\n            // If the ^ above fetch doesn't work, try again with a `.tsx` extension\n            // Some typescript files use `.tsx`\n            try {\n              ({ content, url } = await fetchPkg(argPath(\".tsx\"), events));\n            } catch (e) {\n              events.emit(\"logger.error\", e.toString());\n              throw err;\n            }\n          }\n        }\n\n        // Create a virtual file system for storing node modules\n        // This is for building a package bundle analyzer \n        await FileSystem.set(args.namespace + \":\" + args.path, content);\n\n        let _assetResults =\n          (await fetchAssets(url, content, args.namespace, events, config))\n            .filter((result) => {\n              if (result.status == \"rejected\") {\n                events.emit(\"logger:warn\", \"Asset fetch failed.\\n\" + result?.reason?.toString());\n                return false;\n              } else return true;\n            })\n            .map((result) => {\n              if (result.status == \"fulfilled\")\n                return result.value;\n            });\n\n        state.assets = assets.concat(_assetResults);\n        return {\n          contents: content,\n          loader: inferLoader(url),\n          pluginData: { url, pkg: args.pluginData?.pkg },\n        };\n      });\n    },\n  };\n};","import type { OnResolveArgs, OnResolveResult, Plugin } from 'esbuild-wasm';\nimport type { BundleConfigOptions } from '../configs/options';\nimport type { EVENTS } from '../configs/events';\nimport type { STATE } from '../configs/state';\n\nimport { parsePackageName } from \"../utils/parse-package-name\";\nimport { EXTERNALS_NAMESPACE } from './external';\nimport { HTTP_RESOLVE } from './http';\n\nimport { getCDNUrl, DEFAULT_CDN_HOST } from '../utils/util-cdn';\nimport { isBareImport } from '../utils/path';\n\n/** Alias Plugin Namespace */\nexport const ALIAS_NAMESPACE = 'alias-globals';\n\n/**\n * Checks if a package has an alias\n * \n * @param id The package to find an alias for \n * @param aliases An object with package as the key and the package alias as the value, e.g. { \"fs\": \"memfs\" }\n */\nexport const isAlias = (id: string, aliases = {}) => {\n  if (!isBareImport(id)) return false;\n\n  let aliasKeys = Object.keys(aliases);\n  let path = id.replace(/^node\\:/, \"\");\n  let pkgDetails = parsePackageName(path);\n\n  return aliasKeys.find((it: string): boolean => {\n    return pkgDetails.name === it; // import 'foo' & alias: { 'foo': 'bar@5.0' }\n  });\n};\n\n/**\n * Resolution algorithm for the esbuild ALIAS plugin \n * \n * @param aliases An object with package as the key and the package alias as the value, e.g. { \"fs\": \"memfs\" }\n * @param host The default host origin to use if an import doesn't already have one\n * @param logger Console log\n */\nexport const ALIAS_RESOLVE = (aliases = {}, host = DEFAULT_CDN_HOST, events: typeof EVENTS) => {\n  return async (args: OnResolveArgs): Promise<OnResolveResult> => {\n    let path = args.path.replace(/^node\\:/, \"\");\n    let { path: argPath } = getCDNUrl(path);\n\n    if (isAlias(argPath, aliases)) {\n      let pkgDetails = parsePackageName(argPath);\n      let aliasPath = aliases[pkgDetails.name];\n      return HTTP_RESOLVE(host, events)({\n        ...args,\n        path: aliasPath\n      });\n    }\n  };\n};\n\n/**\n * Esbuild ALIAS plugin \n * \n * @param aliases An object with package as the key and the package alias as the value, e.g. { \"fs\": \"memfs\" }\n * @param host The default host origin to use if an import doesn't already have one\n * @param logger Console log\n */\nexport const ALIAS = (events: typeof EVENTS, state: typeof STATE, config: BundleConfigOptions): Plugin => {\n  // Convert CDN values to URL origins\n  let { origin: host } = !/:/.test(config?.cdn) ? getCDNUrl(config?.cdn + \":\") : getCDNUrl(config?.cdn);\n  let aliases = config.alias ?? {};\n  return {\n    name: ALIAS_NAMESPACE,\n    setup(build) {\n      // Intercept import paths starting with \"http:\" and \"https:\" so\n      // esbuild doesn't attempt to map them to a file system location.\n      // Tag them with the \"http-url\" namespace to associate them with\n      // this plugin.\n      build.onResolve({ filter: /^node\\:.*/ }, (args) => {\n        if (isAlias(args.path, aliases))\n          return ALIAS_RESOLVE(aliases, host, events)(args);\n\n        return {\n          path: args.path,\n          namespace: EXTERNALS_NAMESPACE,\n          external: true\n        };\n      });\n\n      // We also want to intercept all import paths inside downloaded\n      // files and resolve them against the original URL. All of these\n      // files will be in the \"http-url\" namespace. Make sure to keep\n      // the newly resolved URL in the \"http-url\" namespace so imports\n      // inside it will also be resolved as URLs recursively.\n      build.onResolve({ filter: /.*/ }, ALIAS_RESOLVE(aliases, host, events));\n      build.onResolve({ filter: /.*/, namespace: ALIAS_NAMESPACE }, ALIAS_RESOLVE(aliases, host, events));\n    },\n  };\n};","// Based on https://github.com/okikio/bundle/blob/main/src/ts/plugins/virtual-fs.ts\nimport type { Plugin } from 'esbuild-wasm';\nimport type { BundleConfigOptions } from '../configs/options';\nimport type { EVENTS } from \"../configs/events\";\nimport type { STATE } from '../configs/state';\n\nimport { inferLoader } from \"../utils/loader\";\nexport const VIRTUAL_FILESYSTEM_NAMESPACE = 'virtual-filesystem';\nexport const VIRTUAL_FS = (events: typeof EVENTS, state: typeof STATE, config: BundleConfigOptions): Plugin => {\n  const FileSystem = config.filesystem;\n\n  return {\n    name: VIRTUAL_FILESYSTEM_NAMESPACE,\n    setup(build) {\n      build.onResolve({ filter: /.*/ }, (args) => {\n        return {\n          path: args.path,\n          pluginData: args.pluginData ?? {},\n          namespace: VIRTUAL_FILESYSTEM_NAMESPACE\n        };\n      });\n\n      build.onLoad({ filter: /.*/, namespace: VIRTUAL_FILESYSTEM_NAMESPACE }, async (args) => {\n        let resolvedPath = await FileSystem.resolve(args.path, args?.pluginData?.importer);\n        let content = await FileSystem.get(args.path, \"buffer\", args?.pluginData?.importer);\n\n        return {\n          contents: content,\n          pluginData: {\n            importer: resolvedPath,\n          },\n          loader: inferLoader(resolvedPath)\n        };\n      });\n    },\n  };\n};","/**\n * `@bundlejs/core`'s supported platforms\n */\nexport type PLATFORM = \"node\" | \"deno\" | \"browser\";\n\n/**\n * Automatically chooses the esbuild version to run based off platform heuristics, \n * e.g. \n * - The environment is deno if it supports `globalThis.Deno`\n * - The environment is node if it supports `globalThis.process`\n * - Otherwise the environment is the browser\n * \n */\nexport const PLATFORM_AUTO: PLATFORM = (\"Deno\" in globalThis) ? \"deno\" : (\"process\" in globalThis) ? \"node\" : \"browser\";","import { dirname, resolve } from \"../deno/path/mod\";\nimport { decode, encode } from \"./encode-decode\";\n\n/** Virtual Filesystem Storage */\nexport const FileSystem = new Map<string, Uint8Array>();\n\n/**\n * Resolves path to a file in the virtual file system storage \n * \n * @param path the relative or absolute path to resolve to\n * @param importer an absolute path to use to determine relative file paths\n * @returns resolved final path\n */\nexport const getResolvedPath = async (path: string, importer?: string) => {\n  let resolvedPath = path;\n  if (importer && path.startsWith('.'))\n    resolvedPath = resolve(dirname(importer), path);\n\n  if (FileSystem.has(resolvedPath)) return resolvedPath;\n  throw `File \"${resolvedPath}\" does not exist`;\n}\n\n/**\n * Retrevies file from virtual file system storage in either string or uint8array buffer format\n * \n * @param path path of file in virtual file system storage\n * @param type format to retrieve file in, buffer and string are the 2 option available\n * @param importer an absolute path to use to determine a relative file path\n * @returns file from file system storage in either string format or as a Uint8Array buffer\n */\nexport const getFile = async (path: string, type: 'string' | 'buffer' = \"buffer\", importer?: string) => {\n  let resolvedPath = await getResolvedPath(path, importer);\n\n  if (FileSystem.has(resolvedPath)) {\n    let file = FileSystem.get(resolvedPath);\n    return type == \"string\" ? decode(file) : file;\n  }\n}\n\n/**\n * Writes file to filesystem in either string or uint8array buffer format\n * \n * @param path path of file in virtual file system storage\n * @param content contents of file to store, you can store buffers and/or strings\n * @param importer an absolute path to use to determine a relative file path\n */\nexport const setFile = async (path: string, content: Uint8Array | string, importer?: string) => {\n  let resolvedPath = path;\n  if (importer && path.startsWith('.'))\n    resolvedPath = resolve(dirname(importer), path);\n\n  try {\n    FileSystem.set(resolvedPath, content instanceof Uint8Array ? content : encode(content));\n  } catch (e) {\n    throw `Error occurred while writing to \"${resolvedPath}\"`;\n  }\n}","export const isObject = (obj: any) => typeof obj === \"object\" && obj != null;\nexport const isPrimitive = (val) => (typeof val === 'object' ? val === null : typeof val !== 'function');\nexport const isValidKey = key => {\n  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';\n};\n\n// Based on https://gist.github.com/egardner/efd34f270cc33db67c0246e837689cb9\n// Deep Equality comparison example\n//\n// This is an example of how to implement an object-comparison function in \n// JavaScript (ES5+). A few points of interest here:\n//\n// * You can get an array of all an object's properties in ES5+ by calling\n//   the class method Object.keys(obj). \n// * The function recursively calls itself in the for / in loop when it\n//   compares the contents of each property\n// * You can hide a \"private\" function inside a function of this kind by\n//   placing one function declaration inside of another. The inner function\n//   is not hoisted out into the global scope, so it is only visible inside\n//   of the parent function.\n// * The reason this nested helper function is necessary is that \n//   `typeof null` is still \"object\" in JS, a major \"gotcha\" to watch out for.\n//\nexport const deepEqual = (obj1: any, obj2: any) => {\n  if (obj1 === obj2) {\n    return true;\n  } else if (isObject(obj1) && isObject(obj2)) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) { return false; }\n    for (var prop in obj1) {\n      if (!deepEqual(obj1[prop], obj2[prop])) return false;\n    }\n\n    return true;\n  }\n};\n\n/** Compares 2 objects and only keep the keys that are different in both objects */\nexport const deepDiff = (obj1: any, obj2: any) => {\n  let keys = Object.keys(obj2);\n  let result = {};\n  let i = 0;\n  for (; i < keys.length; i++) {\n    let key = keys[i];\n    let value = obj2[key];\n\n    if (key in obj1) {\n      let bothAreArrays = Array.isArray(obj1[key]) && Array.isArray(value);\n      if (obj1[key] == value) {\n        continue;\n      } else if (bothAreArrays) {\n        if (!deepEqual(obj1[key], value))\n          result[key] = value;\n        else continue;\n      } else if (isObject(obj1[key]) && isObject(value)) {\n        // Remove empty objects\n        let diff = deepDiff(obj1[key], value);\n        if (Object.keys(diff).length)\n          result[key] = diff;\n      } else {\n        result[key] = value;\n      }\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result;\n};\n\n/*!\n * Based on assign-deep <https://github.com/jonschlinkert/assign-deep>\n *\n * Copyright (c) 2017-present, Jon Schlinkert.\n * Released under the MIT License.\n */\nexport const deepAssign = (target, ...args) => {\n  let i = 0;\n  if (isPrimitive(target)) target = args[i++];\n  if (!target) target = {};\n  for (; i < args.length; i++) {\n    if (isObject(args[i])) {\n      for (const key of Object.keys(args[i])) {\n        if (isValidKey(key)) {\n          if (isObject(target[key]) && isObject(args[i][key])) {\n            target[key] = deepAssign(Array.isArray(target[key]) ? [] : {}, target[key], args[i][key]);\n          } else {\n            target[key] = args[i][key];\n          }\n        }\n      }\n    }\n  }\n\n  return target;\n};\n","import type { BuildOptions, InitializeOptions, OutputFile } from \"esbuild-wasm\";\nimport type { OutputOptions } from \"rollup\";\n\nimport { PLATFORM_AUTO, type PLATFORM } from \"./platform\";\n\nimport { FileSystem, getFile, setFile, getResolvedPath } from \"../utils/filesystem\";\nimport { DEFAULT_CDN_HOST } from \"../utils/util-cdn\";\nimport { deepAssign } from \"../utils/deep-equal\";\n\n/** The compression algorithim to use, there are currently 3 options \"gzip\", \"brotli\", and \"lz4\" */\nexport type CompressionType = \"gzip\" | \"brotli\" | \"lz4\";\n\n/** \n* You can configure the quality of the compression using an object, \n* e.g.\n* ```ts\n* {\n*  ...\n*  \"compression\": {\n*    \"type\": \"brotli\",\n*    \"quality\": 5\n*  }\n* }\n* ```\n*/\nexport type CompressionOptions = {\n  /** The compression algorithim to use, there are currently 3 options \"gzip\", \"brotli\", and \"lz4\" */\n  type: CompressionType,\n\n  /** Compression quality ranging from 1 to 11 */\n  quality: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11\n};\n\nexport type BundleConfigOptions = {\n  /** Enable using rollup for treeshaking. Only works while the `esbuild.treeShaking` option is true */\n  rollup?: OutputOptions | boolean,\n\n  /** esbuild config options https://esbuild.github.io/api/#build-api */\n  esbuild?: BuildOptions,\n\n  /** The default CDN to import packages from */\n  cdn?: \"https://unpkg.com\" | \"https://esm.run\" | \"https://cdn.esm.sh\" | \"https://cdn.esm.sh\" | \"https://cdn.skypack.dev\" | \"https://cdn.jsdelivr.net/npm\" | \"https://cdn.jsdelivr.net/gh\" | \"https://deno.land/x\" | \"https://raw.githubusercontent.com\" | \"unpkg\" | \"esm.run\" | \"esm.sh\" | \"esm\" | \"skypack\" | \"jsdelivr\" | \"jsdelivr.gh\" | \"github\" | \"deno\" | (string & {}),\n\n  /** Aliases for replacing packages with different ones, e.g. replace \"fs\" with \"memfs\", so, it can work on the web, etc... */\n  alias?: Record<string, string>,\n\n  /** \n   * The compression algorithim to use, there are currently 3 options \"gzip\", \"brotli\", and \"lz4\".\n   * You can also configure the quality of the compression using an object, \n   * e.g.\n   * ```ts\n   * {\n   *  ...\n   *  \"compression\": {\n   *    \"type\": \"brotli\",\n   *    \"quality\": 5\n   *  }\n   * }\n   * ```\n  */\n  compression?: CompressionOptions | CompressionType,\n\n  /**\n   * Enables converting ascii logs to HTML so virtual consoles can handle the logs and print with color\n   */\n  ascii?: \"html\" | \"html-and-ascii\" | \"ascii\",\n  \n  /**\n   * A virtual file system where you can input files, get, set and read files\n   */\n  filesystem?: { \n    /** Virtual Filesystem Storage */\n    files?: typeof FileSystem,\n\n    /**\n     * Retrevies file from virtual file system storage in either string or uint8array buffer format\n     * \n     * @param path path of file in virtual file system storage\n     * @param type format to retrieve file in, buffer and string are the 2 option available\n     * @param importer an absolute path to use to determine a relative file path\n     * @returns file from file system storage in either string format or as a Uint8Array buffer\n     */\n    get?: typeof getFile,\n\n    /**\n     * Writes file to filesystem in either string or uint8array buffer format\n     * \n     * @param path path of file in virtual file system storage\n     * @param content contents of file to store, you can store buffers and/or strings\n     * @param importer an absolute path to use to determine a relative file path\n     */\n    set?: typeof setFile,\n\n    /**\n     * Resolves path to a file in the virtual file system storage \n     * \n     * @param path the relative or absolute path to resolve to\n     * @param importer an absolute path to use to determine relative file paths\n     * @returns resolved final path\n     */\n    resolve?: typeof getResolvedPath,\n\n    /**\n     * Clear all files from the virtual filesystem storage\n     */\n    clear?: typeof FileSystem.clear,\n  },\n\n  /**\n   * Configures how esbuild-wasm is initialized \n   */\n  init?: InitializeOptions & { platform?: PLATFORM }\n\n  /**\n   * Documentation: https://esbuild.github.io/api/#entry-points\n   */\n  entryPoints?: BuildOptions[\"entryPoints\"]\n};\n\nexport const EasyDefaultConfig: BundleConfigOptions = {\n  entryPoints: [\"/index.tsx\"],\n  \"cdn\": DEFAULT_CDN_HOST,\n  \"compression\": \"gzip\",\n  \"esbuild\": {\n    \"target\": [\"esnext\"],\n    \"format\": \"esm\",\n    \"bundle\": true,\n    \"minify\": true,\n\n    \"treeShaking\": true,\n    \"platform\": \"browser\"\n  }\n};\n\nexport const DefaultConfig: BundleConfigOptions = deepAssign({}, EasyDefaultConfig, {\n  \"esbuild\": {\n    \"color\": true,\n    \"globalName\": \"BundledCode\",\n\n    \"logLevel\": \"info\",\n    \"sourcemap\": false,\n    \"incremental\": false,\n  },\n  \n  \"ascii\": \"ascii\",\n  filesystem: { \n    files: FileSystem,\n    get: getFile,\n    set: setFile,\n    resolve: getResolvedPath,\n    clear: () => FileSystem.clear(),\n  },\n  init: {\n    platform: PLATFORM_AUTO\n  }\n} as BundleConfigOptions);","var o=class{constructor(e){this.map=new Map(e)}getMap(){return this.map}get(e){return this.map.get(e)}keys(){return Array.from(this.map.keys())}values(){return Array.from(this.map.values())}set(e,t){return this.map.set(e,t),this}add(e){let n=this.size;return this.set(n,e),this}get size(){return this.map.size}get length(){return this.map.size}last(e=1){let t=this.keys()[this.size-e];return this.get(t)}delete(e){return this.map.delete(e)}remove(e){return this.map.delete(e),this}clear(){return this.map.clear(),this}has(e){return this.map.has(e)}entries(){return this.map.entries()}forEach(e,t){return this.map.forEach(e,t),this}[Symbol.iterator](){return this.entries()}},b=(p,e,...t)=>{p.forEach(n=>{n[e](...t)})};var h=({callback:p=()=>{},scope:e=null,name:t=\"event\"})=>({callback:p,scope:e,name:t}),c=class extends o{constructor(e=\"event\"){super();this.name=e}},y=class extends o{constructor(){super()}getEvent(e){let t=this.get(e);return t instanceof c?t:(this.set(e,new c(e)),this.get(e))}newListener(e,t,n){let r=this.getEvent(e);return r.add(h({name:e,callback:t,scope:n})),r}on(e,t,n){if(typeof e==\"undefined\"||e==null)return this;typeof e==\"string\"&&(e=e.trim().split(/\\s/g));let r,i,a=typeof e==\"object\"&&!Array.isArray(e),l=a?t:n;return a||(i=t),Object.keys(e).forEach(s=>{r=a?s:e[s],a&&(i=e[s]),this.newListener(r,i,l)},this),this}removeListener(e,t,n){let r=this.get(e);if(r instanceof c&&t){let i=h({name:e,callback:t,scope:n});r.forEach((a,l)=>{if(a.callback===i.callback&&a.scope===i.scope)return r.remove(l)})}return r}off(e,t,n){if(typeof e==\"undefined\"||e==null)return this;typeof e==\"string\"&&(e=e.trim().split(/\\s/g));let r,i,a=typeof e==\"object\"&&!Array.isArray(e),l=a?t:n;return a||(i=t),Object.keys(e).forEach(s=>{r=a?s:e[s],a&&(i=e[s]),typeof i==\"function\"?this.removeListener(r,i,l):this.remove(r)},this),this}once(e,t,n){if(typeof e==\"undefined\"||e==null)return this;typeof e==\"string\"&&(e=e.trim().split(/\\s/g));let r=typeof e==\"object\"&&!Array.isArray(e);return Object.keys(e).forEach(i=>{let a=r?i:e[i],l=r?e[i]:t,s=r?t:n,u=(...f)=>{l.apply(s,f),this.removeListener(a,u,s)};this.newListener(a,u,s)},this),this}emit(e,...t){return typeof e==\"undefined\"||e==null?this:(typeof e==\"string\"&&(e=e.trim().split(/\\s/g)),e.forEach(n=>{let r=this.get(n);r instanceof c&&r.forEach(i=>{let{callback:a,scope:l}=i;a.apply(l,t)})},this),this)}clear(){return b(this,\"clear\"),super.clear(),this}},d=y;export{c as Event,y as EventEmitter,d as default,h as newListener};\n","import { EventEmitter } from \"@okikio/emitter\";\nexport const EVENTS_OPTS = {\n  \"init.start\": console.log,\n  \"init.complete\": console.info,\n  \"init.error\": console.error,\n  \"init.loading\": console.warn,\n\n  \"logger.log\": console.log,\n  \"logger.error\": console.error,\n  \"logger.warn\": console.warn,\n  \"logger.info\": console.info\n};\n\nexport const EVENTS = new EventEmitter();\nEVENTS.on(EVENTS_OPTS);","import type { OutputFile } from \"esbuild-wasm\";\nimport type * as ESBUILD from \"esbuild\";\n\nexport const STATE = {\n  initialized: false,\n\n  /**\n   * Assets are files during the build process that esbuild can't handle natively, \n   * e.g. fetching web workers using the `new URL(\"...\", import.meta.url)`\n   */\n  assets: [] as OutputFile[],\n\n  /**\n   * Instance of esbuild being used\n   */\n  esbuild: null as typeof ESBUILD\n};\n\nexport default STATE;","/**\n * Based on `pretty-bytes` (https://npmjs.com/pretty-bytes) by @sindresorhus (https://github.com/sindresorhus)\n * Based on `byte` (https://npmjs.com/bytes) by @visionmedia (https://github.com/visionmedia)\n * \n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\nexport const BYTE_UNITS = [\n  'B',\n  'kB',\n  'MB',\n  'GB',\n  'TB',\n  'PB',\n  'EB',\n  'ZB',\n  'YB',\n];\n\nexport const BIBYTE_UNITS = [\n  'B',\n  'kiB',\n  'MiB',\n  'GiB',\n  'TiB',\n  'PiB',\n  'EiB',\n  'ZiB',\n  'YiB',\n];\n\nexport const BIT_UNITS = [\n  'b',\n  'kbit',\n  'Mbit',\n  'Gbit',\n  'Tbit',\n  'Pbit',\n  'Ebit',\n  'Zbit',\n  'Ybit',\n];\n\nexport const BIBIT_UNITS = [\n  'b',\n  'kibit',\n  'Mibit',\n  'Gibit',\n  'Tibit',\n  'Pibit',\n  'Eibit',\n  'Zibit',\n  'Yibit',\n];\n\n/** \n * Formats the given number using `Number#toLocaleString`.\n * - If locale is a string, the value is expected to be a locale-key (for example: `de`).\n * - If locale is true, the system default locale is used for translation.\n * - If no value for locale is specified, the number is returned unmodified.\n*/\nexport const toLocaleString = (number, locale, options) => {\n  let result = number;\n  if (typeof locale === 'string' || Array.isArray(locale)) {\n    result = number.toLocaleString(locale, options);\n  } else if (locale === true || options !== undefined) {\n    result = number.toLocaleString(undefined, options);\n  }\n\n  return result;\n};\n\n/**\n * Convert bytes to a human readable string: `1337` → `1.34 kB`.\n * \n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n * \n * @param number - The number to format.\n * \n * @example\n * ```\n * import prettyBytes from 'pretty-bytes';\n * prettyBytes(1337);\n * //=> '1.34 kB'\n * prettyBytes(100);\n * //=> '100 B'\n * // Display file size differences\n * prettyBytes(42, {signed: true});\n * //=> '+42 B'\n * // Localized output using German locale\n * prettyBytes(1337, {locale: 'de'});\n * //=> '1,34 kB'\n * ```\n */\nexport default function bytes(number: number, options?: PrettyByteOptions) {\n  if (!Number.isFinite(number)) {\n    throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);\n  }\n\n  options = {\n    bits: false,\n    binary: false,\n    ...options,\n  };\n\n  const UNITS = options.bits\n    ? (options.binary ? BIBIT_UNITS : BIT_UNITS)\n    : (options.binary ? BIBYTE_UNITS : BYTE_UNITS);\n\n  if (options.signed && number === 0) {\n    return ` 0 ${UNITS[0]}`;\n  }\n\n  const isNegative = number < 0;\n  const prefix = isNegative ? '-' : (options.signed ? '+' : '');\n\n  if (isNegative) {\n    number = -number;\n  }\n\n  let localeOptions;\n\n  if (options.minimumFractionDigits !== undefined) {\n    localeOptions = { minimumFractionDigits: options.minimumFractionDigits };\n  }\n\n  if (options.maximumFractionDigits !== undefined) {\n    localeOptions = { maximumFractionDigits: options.maximumFractionDigits, ...localeOptions };\n  }\n\n  if (number < 1) {\n    const numberString = toLocaleString(number, options.locale, localeOptions);\n    return prefix + numberString + ' ' + UNITS[0];\n  }\n\n  const exponent = Math.min(Math.floor(options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3), UNITS.length - 1);\n  number /= (options.binary ? 1024 : 1000) ** exponent;\n\n  if (!localeOptions) {\n    // @ts-ignore\n    number = number.toPrecision(3);\n  }\n\n  const numberString = toLocaleString(Number(number), options.locale, localeOptions);\n  const unit = UNITS[exponent];\n\n  return prefix + numberString + ' ' + unit;\n}\n\nexport { bytes, bytes as formatBytes, bytes as prettyBytes };\n\nexport interface PrettyByteOptions {\n  /**\n   * Include plus sign for positive numbers. If the difference is exactly zero a space character will be prepended instead for better alignment.\n   * @default false\n   */\n  readonly signed?: boolean;\n\n  /**\n   * - If `false`: Output won't be localized.\n   * - If `true`: Localize the output using the system/browser locale.\n   * - If `string`: Expects a [BCP 47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) (For example: `en`, `de`, …)\n   * - If `string[]`: Expects a list of [BCP 47 language tags](https://en.wikipedia.org/wiki/IETF_language_tag) (For example: `en`, `de`, …)\n   * @default false\n   */\n  readonly locale?: boolean | string | readonly string[];\n\n  /**\n   * Format the number as [bits](https://en.wikipedia.org/wiki/Bit) instead of [bytes](https://en.wikipedia.org/wiki/Byte). This can be useful when, for example, referring to [bit rate](https://en.wikipedia.org/wiki/Bit_rate).\n   * @default false\n   * @example\n   * ```\n   * import prettyBytes from 'pretty-bytes';\n   * prettyBytes(1337, {bits: true});\n   * //=> '1.34 kbit'\n   * ```\n   */\n  readonly bits?: boolean;\n\n  /**\n   * Format the number using the [Binary Prefix](https://en.wikipedia.org/wiki/Binary_prefix) instead of the [SI Prefix](https://en.wikipedia.org/wiki/SI_prefix). This can be useful for presenting memory amounts. However, this should not be used for presenting file sizes.\n   * @default false\n   * @example\n   * ```\n   * import prettyBytes from 'pretty-bytes';\n   * prettyBytes(1000, {binary: true});\n   * //=> '1000 bit'\n   * prettyBytes(1024, {binary: true});\n   * //=> '1 kiB'\n   * ```\n   */\n  readonly binary?: boolean;\n\n  /**\n   * The minimum number of fraction digits to display.\n   * If neither `minimumFractionDigits` or `maximumFractionDigits` are set, the default behavior is to round to 3 significant digits.\n   * @default undefined\n   * ```\n   * import prettyBytes from 'pretty-bytes';\n   * // Show the number with at least 3 fractional digits\n   * prettyBytes(1900, {minimumFractionDigits: 3});\n   * //=> '1.900 kB'\n   * prettyBytes(1900);\n   * //=> '1.9 kB'\n   * ```\n   */\n  readonly minimumFractionDigits?: number;\n\n  /**\n   * The maximum number of fraction digits to display.\n   * If neither `minimumFractionDigits` or `maximumFractionDigits` are set, the default behavior is to round to 3 significant digits.\n   * @default undefined\n   * ```\n   * import prettyBytes from 'pretty-bytes';\n   * // Show the number with at most 1 fractional digit\n   * prettyBytes(1920, {maximumFractionDigits: 1});\n   * //=> '1.9 kB'\n   * prettyBytes(1920);\n   * //=> '1.92 kB'\n   * ```\n   */\n  readonly maximumFractionDigits?: number;\n}","// Based off of @hyrious esbuild-repl https://github.com/hyrious/esbuild-repl/blob/main/src/helpers/ansi.ts\n// https://github.com/evanw/esbuild/blob/master/internal/logger/logger.go\nexport const ESCAPE_TO_COLOR = {\n  \"37\": \"dim\",\n  \"31\": \"red\",\n  \"32\": \"green\",\n  \"34\": \"blue\",\n  \"36\": \"cyan\",\n  \"35\": \"magenta\",\n  \"33\": \"yellow\",\n  \"41;31\": \"red-bg-red\",\n  \"41;97\": \"red-bg-white\",\n  \"42;32\": \"green-bg-green\",\n  \"42;97\": \"green-bg-white\",\n  \"44;34\": \"blue-bg-blue\",\n  \"44;97\": \"blue-bg-white\",\n  \"46;36\": \"cyan-bg-cyan\",\n  \"46;30\": \"cyan-bg-black\",\n  \"45;35\": \"magenta-bg-magenta\",\n  \"45;30\": \"magenta-bg-black\",\n  \"43;33\": \"yellow-bg-yellow\",\n  \"43;30\": \"yellow-bg-black\",\n} as const;\n\nexport type Escape = \"0\" | \"1\" | \"4\" | keyof typeof ESCAPE_TO_COLOR;\nexport type Color = typeof ESCAPE_TO_COLOR[keyof typeof ESCAPE_TO_COLOR];\n\n// https://github.com/sindresorhus/escape-goat\nexport function htmlEscape(string: string) {\n  return string\n    .replace(/\\<br\\>/g, \"\\n\")\n    .replace(/\\&/g, \"&amp;\")\n    .replace(/\\\"/g, \"&quot;\")\n    .replace(/\\'/g, \"&#39;\")\n    .replace(/\\</g, \"&lt;\")\n    .replace(/\\>/g, \"&gt;\");\n}\n\nexport class AnsiBuffer {\n  result = \"\";\n  _stack: string[] = [];\n  _bold = false;\n  _underline = false;\n  _link = false;\n  text(text: string) {\n    this.result += htmlEscape(text);\n  }\n  reset() {\n    let close: string | undefined;\n    while ((close = this._stack.pop())) {\n      this.result += close;\n    }\n  }\n  bold() {\n    if (!this._bold) {\n      this._bold = true;\n      this.result += \"<strong>\";\n      this._stack.push(\"</strong>\");\n    }\n  }\n  underline() {\n    if (!this._underline) {\n      this._underline = true;\n      this.result += \"<ins>\";\n      this._stack.push(\"</ins>\");\n    }\n  }\n  last() {\n    return this._stack[this._stack.length - 1];\n  }\n  color(color: Color) {\n    let close: string | undefined;\n    while ((close = this.last()) === \"</span>\") {\n      this._stack.pop();\n      this.result += close;\n    }\n    this.result += `<span class=\"color-${color}\">`;\n    this._stack.push(\"</span>\");\n  }\n  done() {\n    this.reset();\n    return this.result;\n  }\n}\n\nexport function render(ansi: string) {\n  ansi = ansi.trimEnd();\n  let i = 0;\n  const buffer = new AnsiBuffer();\n  for (let m of ansi.matchAll(/\\x1B\\[([\\d;]+)m/g)) {\n    const escape = m[1] as Escape;\n    buffer.text(ansi.slice(i, m.index));\n    i = m.index! + m[0].length;\n      /*  */ if (escape === \"0\") {\n      buffer.reset();\n    } else if (escape === \"1\") {\n      buffer.bold();\n    } else if (escape === \"4\") {\n      buffer.underline();\n    } else if (ESCAPE_TO_COLOR[escape]) {\n      buffer.color(ESCAPE_TO_COLOR[escape]);\n    }\n  }\n  if (i < ansi.length) {\n    buffer.text(ansi.slice(i));\n  }\n  return buffer.done();\n}\n\nexport { render as ansi };\nexport default render;","import type { PartialMessage } from \"esbuild-wasm\";\n\nimport { ansi } from \"./ansi\";\n\n/** \n * Inspired by https://github.com/egoist/play-esbuild/blob/main/src/lib/esbuild.ts\n * I didn't even know this was exported by esbuild, great job @egoist\n*/\nexport const createNotice = async (errors: PartialMessage[], kind: \"error\" | \"warning\" = \"error\", color = true) => {\n  const { formatMessages } = await import(\"esbuild-wasm\");\n  let notices = await formatMessages(errors, { color, kind });\n  return notices.map((msg) => !color ? msg : ansi(msg.replace(/(\\s+)(\\d+)(\\s+)\\│/g, \"\\n$1$2$3│\")));\n}\n\nexport default createNotice;","import type { BundleConfigOptions, CompressionOptions } from \"./configs/options\";\nimport type { PLATFORM } from \"./configs/platform\";\nimport type * as ESBUILD from \"esbuild-wasm\";\n\nexport { type ESBUILD };\n\n// import ESBUILD_WASM from \"./wasm\";\nimport { version } from \"esbuild-wasm/package.json\";\n\nimport { EXTERNAL } from \"./plugins/external\";\nimport { HTTP } from \"./plugins/http\";\nimport { CDN } from \"./plugins/cdn\";\nimport { ALIAS } from \"./plugins/alias\";\nimport { VIRTUAL_FS } from \"./plugins/virtual-fs\";\n\nimport { DefaultConfig } from \"./configs/options\";\nimport { EVENTS } from \"./configs/events\";\nimport { STATE } from \"./configs/state\";\n\nimport { bytes } from \"./utils/pretty-bytes\";\nimport { encode } from \"./utils/encode-decode\";\nimport { deepAssign } from \"./utils/deep-equal\";\n\nimport { createNotice } from \"./utils/create-notice\";\n\nexport const INPUT_EVENTS = {\n  \"build\": build,\n  \"init\": init\n};\n\nexport async function getESBUILD(platform: PLATFORM = \"node\"): Promise<typeof ESBUILD> {\n  try {\n    switch (platform) {\n      case \"node\":\n        return await import(\"esbuild\");\n      case \"deno\":\n        return await import(\n          /* @vite-ignore */\n          `https://deno.land/x/esbuild@v${version}/mod.js`\n        );\n      default:\n        return await import(\"esbuild-wasm\");\n    }\n  } catch (e) {\n    throw e;\n  }\n}\n\nexport async function init({ platform, ...opts }: BundleConfigOptions[\"init\"] = {}) {\n  try {\n    if (!STATE.initialized) {\n      STATE.initialized = true;\n      EVENTS.emit(\"init.start\");\n\n      STATE.esbuild = await getESBUILD(platform);\n      if (platform !== \"node\" && platform !== \"deno\") {\n        const { default: ESBUILD_WASM } = await import(\"./wasm\");\n        await STATE.esbuild.initialize({\n          wasmModule: new WebAssembly.Module(await ESBUILD_WASM()),\n          ...opts\n        });\n      }\n\n      EVENTS.emit(\"init.complete\");\n    }\n\n    return STATE.esbuild;\n  } catch (error) {\n    EVENTS.emit(\"init.error\", error);\n    console.error(error);\n  }\n}\n\nexport async function build(opts: BundleConfigOptions = {}): Promise<any> {\n  if (!STATE.initialized)\n    EVENTS.emit(\"init.loading\");\n\n  const CONFIG = deepAssign({}, DefaultConfig, opts) as BundleConfigOptions;\n\n  const { build: bundle } = await init(CONFIG.init);\n  const { define = {}, loader = {}, ...esbuildOpts } = CONFIG.esbuild ?? {};\n\n  // Stores content from all external outputed files, this is for checking the gzip size when dealing with CSS and other external files\n  let outputs: ESBUILD.OutputFile[] = [];\n  let contents: ESBUILD.OutputFile[] = [];\n  let result: ESBUILD.BuildResult | ESBUILD.BuildIncremental;\n\n  try {\n    try {\n      const keys = \"p.env.NODE_ENV\".replace(\"p.\", \"process.\");\n      result = await bundle({\n        entryPoints: CONFIG?.entryPoints ?? [],\n        loader: {\n          '.png': 'file',\n          '.jpeg': 'file',\n          '.ttf': 'file',\n          '.svg': 'text',\n          '.html': 'text',\n          '.scss': 'css'\n        },\n        define: {\n          \"__NODE__\": `false`,\n          // vite crashes for some reason when it sees \"process.env.NODE_ENV\"\n          [keys]: `\"production\"`,\n          ...define\n        },\n        write: false,\n        outdir: \"/\",\n        plugins: [\n          ALIAS(EVENTS, STATE, CONFIG),\n          EXTERNAL(EVENTS, STATE, CONFIG),\n          HTTP(EVENTS, STATE, CONFIG),\n          CDN(EVENTS, STATE, CONFIG),\n          VIRTUAL_FS(EVENTS, STATE, CONFIG),\n        ],\n        ...esbuildOpts,\n      });\n    } catch (e) {\n      if (e.errors) {\n        // Log errors with added color info. to the virtual console\n        const asciMsgs = [...await createNotice(e.errors, \"error\", false)];\n        const htmlMsgs = [...await createNotice(e.errors, \"error\")];\n\n        EVENTS.emit(\"logger.error\", asciMsgs, htmlMsgs);\n\n        const message = (htmlMsgs.length > 1 ? `${htmlMsgs.length} error(s) ` : \"\") + \"(if you are having trouble solving this issue, please create a new issue in the repo, https://github.com/okikio/bundle)\";\n        return EVENTS.emit(\"logger.error\", message);\n      } else throw e;\n    }\n\n    // Create an array of assets and actual output files, this will later be used to calculate total file size\n    outputs = await Promise.all(\n      [...STATE.assets]\n        .concat(result?.outputFiles as ESBUILD.OutputFile[])\n    );\n\n    contents = await Promise.all(\n      outputs\n        ?.map(({ path, text, contents }): ESBUILD.OutputFile => {\n          if (/\\.map$/.test(path))\n            return { path, text: \"\", contents: encode(\"\") };\n\n          // For debugging reasons, if the user chooses verbose, print all the content to the Shared Worker console\n          if (esbuildOpts?.logLevel == \"verbose\") {\n            const ignoreFile = /\\.(wasm|png|jpeg|webp)$/.test(path);\n            if (ignoreFile) {\n              EVENTS.emit(\"logger.log\", \"Output File: \" + path);\n            } else {\n              EVENTS.emit(\"logger.log\", \"Output File: \" + path + \"\\n\" + text);\n            }\n          }\n\n          return { path, text, contents };\n        })\n    );\n\n    // Ensure a fresh filesystem on every run\n    // FileSystem.clear();\n\n    // Reset assets\n    // STATE.assets = [];\n\n    return {\n      // Remove unesscary croft, e.g. `.map` sourcemap files\n      content: contents,\n      ...result.outputFiles\n    };\n  } catch (e) { }\n}\n\n/**\n * \n * @param contents \n * @param opts \n * @returns \n */\nexport async function getSize(contents: ESBUILD.OutputFile[] = [], opts: BundleConfigOptions = {}) {\n  const CONFIG = deepAssign({}, DefaultConfig, opts) as BundleConfigOptions;\n\n  // Use multiple compression algorithims & pretty-bytes for the total gzip, brotli & lz4 compressed size\n  let { compression = {} } = CONFIG;\n  let { type = \"gzip\", quality: level = 9 } =\n    (typeof compression == \"string\" ? { type: compression } : (compression ?? {})) as CompressionOptions;\n\n  // @ts-ignore\n  let totalByteLength = bytes(\n    contents.reduce((acc, { contents }) => acc + contents.byteLength, 0)\n  ) as string;\n\n  // Choose a different compression function based on the compression type\n  let compressionMap = await (async () => {\n    switch (type) {\n      case \"lz4\":\n        const { compress: lz4_compress, getWASM: getLZ4 } = await import(\"./deno/lz4/mod\");\n        await getLZ4();\n        return async (code: Uint8Array) => {\n          return await lz4_compress(code);\n        };\n      case \"brotli\":\n        const { compress, getWASM: getBrotli } = await import(\"./deno/brotli/mod\");\n        await getBrotli();\n        return async (code: Uint8Array) => {\n          return await compress(code, code.length, level);\n        };\n      default:\n        const { gzip, getWASM: getGZIP } = await import(\"./deno/denoflate/mod\");\n        await getGZIP();\n        return async (code: Uint8Array) => {\n          return await gzip(code, level);\n        };\n    }\n  })();\n\n  let compressedContent = await Promise.all(\n    contents.map(({ contents }) => compressionMap(contents))\n  );\n  \n  let totalCompressedSize = bytes(\n    compressedContent.reduce((acc, { length }) => acc + length, 0)\n  );\n\n  return {\n    type,\n    content: compressedContent,\n\n    totalByteLength,\n    totalCompressedSize,\n\n    initialSize: `${totalByteLength}`,\n    size: `${totalCompressedSize} (${type})`\n  };\n}\n\nexport { };","// Based on https://davidwalsh.name/javascript-debounce-function\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\nexport const debounce = (func: (...args: any[]) => any, wait: number = 300, immediate?: boolean) => {\n  let timeout: number | null;\n  return function (...args: any[]) {\n    let context = this;\n    let later = () => {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n\n    let callNow = immediate && !timeout;\n    clearTimeout(timeout);\n\n    // @ts-ignore\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};","/**\n * Based on `@amoutonbrady/lz-string` (https://npmjs.com/@amoutonbrady/lz-string) by @amoutonbrady (https://github.com/amoutonbrady)\n */\n\n// private property\nexport const keyStrBase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nexport const keyStrUriSafe = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$';\nexport const baseReverseDic: Record<string, Record<string, number>> = {};\n\nexport function getBaseValue(alphabet: string, character: string) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n\n    for (let i = 0; i < alphabet.length; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n\n  return baseReverseDic[alphabet][character];\n}\n\nexport function compressToBase64(input: string): string {\n  if (input == null) return '';\n  const res = _compress(input, 6, (a) => keyStrBase64.charAt(a));\n\n  // To produce valid Base64\n  switch (res.length % 4) {\n    default: // When could this happen ?\n    case 0:\n      return res;\n    case 1:\n      return res + '===';\n    case 2:\n      return res + '==';\n    case 3:\n      return res + '=';\n  }\n}\n\nexport function decompressFromBase64(input: string): string | null {\n  if (input == null) return '';\n  if (input == '') return null;\n  return _decompress(input.length, 32, (index) => getBaseValue(keyStrBase64, input.charAt(index)));\n}\n\n//compress into a string that is already URI encoded\nexport function compressToURL(input: string): string {\n  if (input == null) return '';\n  return _compress(input, 6, (a) => keyStrUriSafe.charAt(a));\n}\n\n//decompress from an output of decompressFromURL\nexport function decompressFromURL(input: string): string | null {\n  if (input == null) return '';\n  if (input == '') return null;\n  input = input.replaceAll(' ', '+');\n\n  return _decompress(input.length, 32, (index) => getBaseValue(keyStrUriSafe, input.charAt(index)));\n}\n\nexport function compress(uncompressed: string): string {\n  return _compress(uncompressed, 16, String.fromCharCode);\n}\n\nexport function decompress(compressed: null | string): string | null {\n  if (compressed == null) return '';\n  if (compressed == '') return null;\n  return _decompress(compressed.length, 32768, (index) => compressed.charCodeAt(index));\n}\n\n/**\n * @internal\n */\nexport function _compress(\n  uncompressed: null | string,\n  bitsPerChar: number,\n  getCharFromInt: (int: number) => string,\n) {\n  if (uncompressed == null) return '';\n\n  const contextData = [];\n  const contextDictionary: Record<string, number> = {};\n  const contextDictionaryToCreate: Record<string, boolean> = {};\n\n  let i: number;\n  let j: number;\n  let value: number;\n\n  let contextC = '';\n  let contextW = '';\n  let contextWc = '';\n\n  // Compensate for the first entry which should not count\n  let contextEnlargeIn = 2;\n  let contextDictSize = 3;\n  let contextNumBits = 2;\n  let contextDataVal = 0;\n  let contextDataPosition = 0;\n\n  for (j = 0; j < uncompressed.length; j += 1) {\n    contextC = uncompressed.charAt(j);\n\n    if (!Object.prototype.hasOwnProperty.call(contextDictionary, contextC)) {\n      contextDictionary[contextC] = contextDictSize++;\n      contextDictionaryToCreate[contextC] = true;\n    }\n\n    contextWc = contextW + contextC;\n\n    if (Object.prototype.hasOwnProperty.call(contextDictionary, contextWc)) {\n      contextW = contextWc;\n    } else {\n      if (Object.prototype.hasOwnProperty.call(contextDictionaryToCreate, contextW)) {\n        if (contextW.charCodeAt(0) < 256) {\n          for (i = 0; i < contextNumBits; i++) {\n            contextDataVal = contextDataVal << 1;\n            if (contextDataPosition == bitsPerChar - 1) {\n              contextDataPosition = 0;\n              contextData.push(getCharFromInt(contextDataVal));\n              contextDataVal = 0;\n            } else {\n              contextDataPosition++;\n            }\n          }\n          value = contextW.charCodeAt(0);\n          for (i = 0; i < 8; i++) {\n            contextDataVal = (contextDataVal << 1) | (value & 1);\n            if (contextDataPosition == bitsPerChar - 1) {\n              contextDataPosition = 0;\n              contextData.push(getCharFromInt(contextDataVal));\n              contextDataVal = 0;\n            } else {\n              contextDataPosition++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i = 0; i < contextNumBits; i++) {\n            contextDataVal = (contextDataVal << 1) | value;\n            if (contextDataPosition == bitsPerChar - 1) {\n              contextDataPosition = 0;\n              contextData.push(getCharFromInt(contextDataVal));\n              contextDataVal = 0;\n            } else {\n              contextDataPosition++;\n            }\n            value = 0;\n          }\n          value = contextW.charCodeAt(0);\n          for (i = 0; i < 16; i++) {\n            contextDataVal = (contextDataVal << 1) | (value & 1);\n            if (contextDataPosition == bitsPerChar - 1) {\n              contextDataPosition = 0;\n              contextData.push(getCharFromInt(contextDataVal));\n              contextDataVal = 0;\n            } else {\n              contextDataPosition++;\n            }\n            value = value >> 1;\n          }\n        }\n        contextEnlargeIn--;\n        if (contextEnlargeIn == 0) {\n          contextEnlargeIn = Math.pow(2, contextNumBits);\n          contextNumBits++;\n        }\n        delete contextDictionaryToCreate[contextW];\n      } else {\n        value = contextDictionary[contextW];\n        for (i = 0; i < contextNumBits; i++) {\n          contextDataVal = (contextDataVal << 1) | (value & 1);\n          if (contextDataPosition == bitsPerChar - 1) {\n            contextDataPosition = 0;\n            contextData.push(getCharFromInt(contextDataVal));\n            contextDataVal = 0;\n          } else {\n            contextDataPosition++;\n          }\n          value = value >> 1;\n        }\n      }\n      contextEnlargeIn--;\n      if (contextEnlargeIn == 0) {\n        contextEnlargeIn = Math.pow(2, contextNumBits);\n        contextNumBits++;\n      }\n      // Add wc to the dictionary.\n      contextDictionary[contextWc] = contextDictSize++;\n      contextW = String(contextC);\n    }\n  }\n\n  // Output the code for w.\n  if (contextW !== '') {\n    if (Object.prototype.hasOwnProperty.call(contextDictionaryToCreate, contextW)) {\n      if (contextW.charCodeAt(0) < 256) {\n        for (i = 0; i < contextNumBits; i++) {\n          contextDataVal = contextDataVal << 1;\n          if (contextDataPosition == bitsPerChar - 1) {\n            contextDataPosition = 0;\n            contextData.push(getCharFromInt(contextDataVal));\n            contextDataVal = 0;\n          } else {\n            contextDataPosition++;\n          }\n        }\n        value = contextW.charCodeAt(0);\n        for (i = 0; i < 8; i++) {\n          contextDataVal = (contextDataVal << 1) | (value & 1);\n          if (contextDataPosition == bitsPerChar - 1) {\n            contextDataPosition = 0;\n            contextData.push(getCharFromInt(contextDataVal));\n            contextDataVal = 0;\n          } else {\n            contextDataPosition++;\n          }\n          value = value >> 1;\n        }\n      } else {\n        value = 1;\n        for (i = 0; i < contextNumBits; i++) {\n          contextDataVal = (contextDataVal << 1) | value;\n          if (contextDataPosition == bitsPerChar - 1) {\n            contextDataPosition = 0;\n            contextData.push(getCharFromInt(contextDataVal));\n            contextDataVal = 0;\n          } else {\n            contextDataPosition++;\n          }\n          value = 0;\n        }\n        value = contextW.charCodeAt(0);\n        for (i = 0; i < 16; i++) {\n          contextDataVal = (contextDataVal << 1) | (value & 1);\n          if (contextDataPosition == bitsPerChar - 1) {\n            contextDataPosition = 0;\n            contextData.push(getCharFromInt(contextDataVal));\n            contextDataVal = 0;\n          } else {\n            contextDataPosition++;\n          }\n          value = value >> 1;\n        }\n      }\n      contextEnlargeIn--;\n      if (contextEnlargeIn == 0) {\n        contextEnlargeIn = Math.pow(2, contextNumBits);\n        contextNumBits++;\n      }\n      delete contextDictionaryToCreate[contextW];\n    } else {\n      value = contextDictionary[contextW];\n      for (i = 0; i < contextNumBits; i++) {\n        contextDataVal = (contextDataVal << 1) | (value & 1);\n        if (contextDataPosition == bitsPerChar - 1) {\n          contextDataPosition = 0;\n          contextData.push(getCharFromInt(contextDataVal));\n          contextDataVal = 0;\n        } else {\n          contextDataPosition++;\n        }\n        value = value >> 1;\n      }\n    }\n    contextEnlargeIn--;\n    if (contextEnlargeIn == 0) {\n      contextEnlargeIn = Math.pow(2, contextNumBits);\n      contextNumBits++;\n    }\n  }\n\n  // Mark the end of the stream\n  value = 2;\n\n  for (i = 0; i < contextNumBits; i++) {\n    contextDataVal = (contextDataVal << 1) | (value & 1);\n    if (contextDataPosition == bitsPerChar - 1) {\n      contextDataPosition = 0;\n      contextData.push(getCharFromInt(contextDataVal));\n      contextDataVal = 0;\n    } else contextDataPosition++;\n\n    value = value >> 1;\n  }\n\n  // Flush the last char\n  while (true) {\n    contextDataVal = contextDataVal << 1;\n    if (contextDataPosition == bitsPerChar - 1) {\n      contextData.push(getCharFromInt(contextDataVal));\n      break;\n    } else contextDataPosition++;\n  }\n\n  return contextData.join('');\n}\n\n/**\n * @internal\n */\nexport function _decompress(length: number, resetValue: number, getNextValue: (index: number) => number) {\n  let dictionary: (string | number)[] = [];\n  let next: number;\n  let enlargeIn = 4;\n  let dictSize = 4;\n  let numBits = 3;\n  let entry: string = '';\n  let result = [];\n  let i: number;\n  let w: string | number;\n  let bits: number;\n  let resb: number;\n  let maxpower: number;\n  let power: number;\n  let c: string | number;\n  let data = { val: getNextValue(0), position: resetValue, index: 1 };\n\n  for (i = 0; i < 3; i += 1) dictionary[i] = i;\n\n  bits = 0;\n  maxpower = Math.pow(2, 2);\n  power = 1;\n  while (power != maxpower) {\n    resb = data.val & data.position;\n    data.position >>= 1;\n    if (data.position == 0) {\n      data.position = resetValue;\n      data.val = getNextValue(data.index++);\n    }\n    bits |= (resb > 0 ? 1 : 0) * power;\n    power <<= 1;\n  }\n\n  switch ((next = bits)) {\n    case 0:\n      bits = 0;\n      maxpower = Math.pow(2, 8);\n      power = 1;\n      while (power != maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb > 0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n      c = String.fromCharCode(bits);\n      break;\n    case 1:\n      bits = 0;\n      maxpower = Math.pow(2, 16);\n      power = 1;\n      while (power != maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb > 0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n      c = String.fromCharCode(bits);\n      break;\n    case 2:\n      return '';\n  }\n  dictionary[3] = c! as string;\n  w = c!;\n  result.push(c!);\n  while (true) {\n    if (data.index > length) {\n      return '';\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2, numBits);\n    power = 1;\n    while (power != maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb > 0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch ((c = bits)) {\n      case 0:\n        bits = 0;\n        maxpower = Math.pow(2, 8);\n        power = 1;\n        while (power != maxpower) {\n          resb = data.val & data.position;\n          data.position >>= 1;\n          if (data.position == 0) {\n            data.position = resetValue;\n            data.val = getNextValue(data.index++);\n          }\n          bits |= (resb > 0 ? 1 : 0) * power;\n          power <<= 1;\n        }\n\n        dictionary[dictSize++] = String.fromCharCode(bits);\n        c = dictSize - 1;\n        enlargeIn--;\n        break;\n      case 1:\n        bits = 0;\n        maxpower = Math.pow(2, 16);\n        power = 1;\n        while (power != maxpower) {\n          resb = data.val & data.position;\n          data.position >>= 1;\n          if (data.position == 0) {\n            data.position = resetValue;\n            data.val = getNextValue(data.index++);\n          }\n          bits |= (resb > 0 ? 1 : 0) * power;\n          power <<= 1;\n        }\n        dictionary[dictSize++] = String.fromCharCode(bits);\n        c = dictSize - 1;\n        enlargeIn--;\n        break;\n      case 2:\n        return result.join('');\n    }\n\n    if (enlargeIn == 0) {\n      enlargeIn = Math.pow(2, numBits);\n      numBits++;\n    }\n\n    if (dictionary[c]) {\n      entry = dictionary[c] as string;\n    } else {\n      if (c === dictSize && typeof w === 'string') {\n        entry = w + w.charAt(0);\n      } else {\n        return null;\n      }\n    }\n    result.push(entry);\n\n    // Add w+entry[0] to the dictionary.\n    dictionary[dictSize++] = w + entry.charAt(0);\n    enlargeIn--;\n\n    w = entry;\n\n    if (enlargeIn == 0) {\n      enlargeIn = Math.pow(2, numBits);\n      numBits++;\n    }\n  }\n}","import * as lzstring from \"./lz-string\";\nimport { EasyDefaultConfig } from \"../configs/options\";\nimport { deepAssign } from \"./deep-equal\";\n\nconst { decompressFromURL } = lzstring;\n\n/**\n * Treeshake exports/imports. It allows for specifing multiple exports per package, through this syntax\n * ```ts\n * \"[{ x,y,z }],[*],[* as X],[{ type xyz }]\" \n * // to\n * export { x, y, z } from \"...\";\n * export * from \"...\";\n * export * as X from \"...\";\n * export { type xyz } from \"...\";\n * ```\n * where the square brackets represent seperate packages, and everything inside the squarebrackets,\n * are the exported methods, types, etc...\n */\nexport const parseTreeshakeExports = (str: string) =>\n  (str ?? \"\").split(/\\],/).map((str) => str.replace(/\\[|\\]/g, \"\"));\n\n// Inspired by https://github.com/solidjs/solid-playground\n/**\n* Converts URL's into code. It allows for specifing multiple exports per package, through this syntax\n* ```ts\n* \"/?q=(import)@okikio/emitter,(import)@okikio/animate,(import)@okikio/animate,(import)@okikio/animate,(import)@okikio/animate,@okikio/animate,@okikio/animate,@okikio/animate,@okikio/animate&treeshake=[T],[{+animate+}],[{+animate+as+B+}],[*+as+TR],[{+type+animate+}],[*],[{+animate+as+A+}],[*+as+PR],[{+animate+}]&share=MYewdgziA2CmB00QHMAUAiAwiG6CUQA\" \n* // to\n* // Click Build for the Bundled, Minified & Gzipped package size\n* import T from \"@okikio/emitter\";\n* import { animate } from \"@okikio/animate\";\n* import { animate as B } from \"@okikio/animate\";\n* import * as TR from \"@okikio/animate\";\n* import { type animate } from \"@okikio/animate\";\n* export * from \"@okikio/animate\";\n* export { animate as A } from \"@okikio/animate\";\n* export * as PR from \"@okikio/animate\";\n* export { animate } from \"@okikio/animate\";\n* console.log(\"Cool\")\n* ```\n* - `q` represents the module, e.g. react, vue, etc... You can add `(import)` in-front of a specific module to make it an import instead of an export\n* - `treeshake` represents the exports to treeshake. Read more about this here, {@link parseTreeshakeExports}\n* - `share` represents all other code that isn't export/import\n*/\nexport const parseShareQuery = (shareURL: URL) => {\n  try {\n    const searchParams = shareURL.searchParams;\n    let result = \"\";\n    let query = searchParams.get(\"query\") || searchParams.get(\"q\");\n    let treeshake = searchParams.get(\"treeshake\");\n    if (query) {\n      let queryArr = query.trim().split(\",\");\n      let treeshakeArr = parseTreeshakeExports((treeshake ?? \"\").trim());\n      result += (\n        \"// Click Build for the Bundled, Minified & Compressed package size\\n\" +\n        queryArr\n          .map((q, i) => {\n            let treeshakeExports =\n              treeshakeArr[i] && treeshakeArr[i].trim() !== \"*\"\n                ? treeshakeArr[i].trim().split(\",\").join(\", \")\n                : \"*\";\n            let [, ,\n              declaration = \"export\",\n              module\n            ] = /^(\\((.*)\\))?(.*)/.exec(q);\n            return `${declaration} ${treeshakeExports} from ${JSON.stringify(\n              module\n            )};`;\n          })\n          .join(\"\\n\")\n      );\n    }\n\n    let share = searchParams.get(\"share\");\n    if (share) result += \"\\n\" + decompressFromURL(share.trim());\n\n    let plaintext = searchParams.get(\"text\");\n    if (plaintext) {\n      result += \"\\n\" + JSON.parse(\n        /**    \n         * Support users wrapping/not-wrapping plaintext in a string, \n         * e.g. \n         * ```md\n         * \n         * \n         * /?text=\"console.log(document)\\nconsole.log(window)\"\n         * and\n         * /?text=console.log(document)\\nconsole.log(window)\n         * \n         * \n         * are the same, they result in \n         * ```ts\n         * console.log(document)\n         * console.log(window)\n         * ```\n        */\n        /^[\"']/.test(plaintext) && /[\"']$/.test(plaintext) ? plaintext : JSON.stringify(\"\" + plaintext).replace(/\\\\\\\\/g, \"\\\\\")\n      );\n    }\n\n    return result.trim();\n  } catch (e) { }\n};\n\n/**\n* Converts URL's into config. \n* - `config` represents the JSON config\n*/\nexport const parseConfig = (shareURL: URL) => {\n  try {\n    const searchParams = shareURL.searchParams;\n    const config = searchParams.get(\"config\") ?? \"{}\";\n    return deepAssign({}, EasyDefaultConfig, JSON.parse(config ? config : \"{}\"));\n  } catch (e) { }\n};","/**\n * Based on `semver` (https://npmjs.com/semver) by @npm (https://github.com/npm) a stripped down version that only allows for selecting the max satisfying version of a range of versions.\n */\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexport const SEMVER_SPEC_VERSION = '2.0.0'\n\nexport const MAX_LENGTH = 256\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nexport const MAX_SAFE_COMPONENT_LENGTH = 16\n\nexport let R = 0\n\nexport const createToken = (pattern: string, isGlobal?) => {\n  const index = R++;\n  return { index, pattern, regex: new RegExp(pattern, isGlobal ? 'g' : undefined) };\n}\n\nconst NUMERICIDENTIFIER = '0|[1-9]\\\\d*';\nconst NUMERICIDENTIFIERLOOSE = '[0-9]+';\n\nconst NONNUMERICIDENTIFIER = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\nconst PRERELEASEIDENTIFIER = `(?:${NUMERICIDENTIFIER}|${NONNUMERICIDENTIFIER})`;\nconst PRERELEASEIDENTIFIERLOOSE = `(?:${NUMERICIDENTIFIERLOOSE}|${NONNUMERICIDENTIFIER})`;\n\nconst BUILDIDENTIFIER = '[0-9A-Za-z-]+';\n\nconst MAINVERSION = `(${NUMERICIDENTIFIER})\\\\.` + `(${NUMERICIDENTIFIER})\\\\.` + `(${NUMERICIDENTIFIER})`;\nconst MAINVERSIONLOOSE = `(${NUMERICIDENTIFIERLOOSE})\\\\.` + `(${NUMERICIDENTIFIERLOOSE})\\\\.` + `(${NUMERICIDENTIFIERLOOSE})`;\n\nconst BUILD = `(?:\\\\+(${BUILDIDENTIFIER}(?:\\\\.${BUILDIDENTIFIER})*))`;\n\nconst PRERELEASE = `(?:-(${PRERELEASEIDENTIFIER}(?:\\\\.${PRERELEASEIDENTIFIER})*))`;\nconst PRERELEASELOOSE = `(?:-?(${PRERELEASEIDENTIFIERLOOSE}(?:\\\\.${PRERELEASEIDENTIFIERLOOSE})*))`;\n\nconst FULLPLAIN = `v?${MAINVERSION}${PRERELEASE}?${BUILD}?`;\nconst LOOSEPLAIN = `[v=\\\\s]*${MAINVERSIONLOOSE}${PRERELEASELOOSE}?${BUILD}?`;\n\nconst XRANGEIDENTIFIER = `${NUMERICIDENTIFIER}|x|X|\\\\*`;\nconst XRANGEIDENTIFIERLOOSE = `${NUMERICIDENTIFIERLOOSE}|x|X|\\\\*`;\n\nconst GTLT = '((?:<|>)?=?)';\n\nconst XRANGEPLAIN = `[v=\\\\s]*(${XRANGEIDENTIFIER})` + `(?:\\\\.(${XRANGEIDENTIFIER})` + `(?:\\\\.(${XRANGEIDENTIFIER})` + `(?:${PRERELEASE})?${BUILD}?` + `)?)?`;\n\nconst XRANGEPLAINLOOSE = `[v=\\\\s]*(${XRANGEIDENTIFIERLOOSE})` + `(?:\\\\.(${XRANGEIDENTIFIERLOOSE})` + `(?:\\\\.(${XRANGEIDENTIFIERLOOSE})` + `(?:${PRERELEASELOOSE})?${BUILD}?` + `)?)?`;\n\nconst COERCE = `${'(^|[^\\\\d])' + '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\\\d])`;\n\nconst LONETILDE = '(?:~>?)';\nconst LONECARET = '(?:\\\\^)';\n\nexport const tokens = {\n  // The following Regular Expressions can be used for tokenizing,\n  // validating, and parsing SemVer version strings.\n\n  // ## Numeric Identifier\n  // A single `0`, or a non-zero digit followed by zero or more digits.\n\n  NUMERICIDENTIFIER: createToken(NUMERICIDENTIFIER),\n  NUMERICIDENTIFIERLOOSE: createToken(NUMERICIDENTIFIERLOOSE),\n\n  // ## Non-numeric Identifier\n  // Zero or more digits, followed by a letter or hyphen, and then zero or\n  // more letters, digits, or hyphens.\n\n  NONNUMERICIDENTIFIER: createToken(NONNUMERICIDENTIFIER),\n\n  // ## Main Version\n  // Three dot-separated numeric identifiers.\n\n  MAINVERSION: createToken(MAINVERSION),\n\n  MAINVERSIONLOOSE: createToken(MAINVERSIONLOOSE),\n\n  // ## Pre-release Version Identifier\n  // A numeric identifier, or a non-numeric identifier.\n\n  PRERELEASEIDENTIFIER: createToken(PRERELEASEIDENTIFIER),\n\n  PRERELEASEIDENTIFIERLOOSE: createToken(PRERELEASEIDENTIFIERLOOSE),\n\n  // ## Pre-release Version\n  // Hyphen, followed by one or more dot-separated pre-release version\n  // identifiers.\n\n  PRERELEASE: createToken(PRERELEASE),\n\n  PRERELEASELOOSE: createToken(PRERELEASELOOSE),\n\n  // ## Build Metadata Identifier\n  // Any combination of digits, letters, or hyphens.\n\n  BUILDIDENTIFIER: createToken(BUILDIDENTIFIER),\n\n  // ## Build Metadata\n  // Plus sign, followed by one or more period-separated build metadata\n  // identifiers.\n\n  BUILD: createToken(BUILD),\n\n  // ## Full Version String\n  // A main version, followed optionally by a pre-release version and\n  // build metadata.\n\n  // Note that the only major, minor, patch, and pre-release sections of\n  // the version string are capturing groups.  The build metadata is not a\n  // capturing group, because it should not ever be used in version\n  // comparison.\n\n  FULLPLAIN: createToken(FULLPLAIN),\n\n  FULL: createToken(`^${FULLPLAIN}$`),\n\n  // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n  // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n  // common in the npm registry.\n  LOOSEPLAIN: createToken(LOOSEPLAIN),\n\n  LOOSE: createToken(`^${LOOSEPLAIN}$`),\n\n  GTLT: createToken(GTLT),\n\n  // Something like \"2.*\" or \"1.2.x\".\n  // Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n  // Only the first item is strictly required.\n  XRANGEIDENTIFIERLOOSE: createToken(XRANGEIDENTIFIERLOOSE),\n  XRANGEIDENTIFIER: createToken(XRANGEIDENTIFIER),\n\n  XRANGEPLAIN: createToken(XRANGEPLAIN),\n\n  XRANGEPLAINLOOSE: createToken(XRANGEPLAINLOOSE),\n\n  XRANGE: createToken(`^${GTLT}\\\\s*${XRANGEPLAIN}$`),\n  XRANGELOOSE: createToken(`^${GTLT}\\\\s*${XRANGEPLAINLOOSE}$`),\n\n  // Coercion.\n  // Extract anything that could conceivably be a part of a valid semver\n  COERCE: createToken(COERCE),\n  COERCERTL: createToken(COERCE, true),\n\n  // Tilde ranges.\n  // Meaning is \"reasonably at or greater than\"\n  LONETILDE: createToken('(?:~>?)'),\n\n  TILDETRIM: createToken(`(\\\\s*)${LONETILDE}\\\\s+`, true),\n\n  TILDE: createToken(`^${LONETILDE}${XRANGEPLAIN}$`),\n  TILDELOOSE: createToken(`^${LONETILDE}${XRANGEPLAINLOOSE}$`),\n\n  // Caret ranges.\n  // Meaning is \"at least and backwards compatible with\"\n  LONECARET: createToken('(?:\\\\^)'),\n\n  CARETTRIM: createToken(`(\\\\s*)${LONECARET}\\\\s+`, true),\n\n  CARET: createToken(`^${LONECARET}${XRANGEPLAIN}$`),\n  CARETLOOSE: createToken(`^${LONECARET}${XRANGEPLAINLOOSE}$`),\n\n  // A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\n  COMPARATORLOOSE: createToken(`^${GTLT}\\\\s*(${LOOSEPLAIN})$|^$`),\n  COMPARATOR: createToken(`^${GTLT}\\\\s*(${FULLPLAIN})$|^$`),\n\n  // An expression to strip any whitespace between the gtlt and the thing\n  // it modifies, so that `> 1.2.3` ==> `>1.2.3`\n  COMPARATORTRIM: createToken(`(\\\\s*)${GTLT\n    }\\\\s*(${LOOSEPLAIN}|${XRANGEPLAIN})`, true),\n\n  // Something like `1.2.3 - 1.2.4`\n  // Note that these all use the loose form, because they'll be\n  // checked against either the strict or loose comparator form\n  // later.\n  HYPHENRANGE: createToken(`^\\\\s*(${XRANGEPLAIN})` +\n    `\\\\s+-\\\\s+` +\n    `(${XRANGEPLAIN})` +\n    `\\\\s*$`),\n\n  HYPHENRANGELOOSE: createToken(`^\\\\s*(${XRANGEPLAINLOOSE})` +\n    `\\\\s+-\\\\s+` +\n    `(${XRANGEPLAINLOOSE})` +\n    `\\\\s*$`),\n\n  // Star ranges basically just allow anything at all.\n  STAR: createToken('(<|>)?=?\\\\s*\\\\*'),\n  // >=0.0.0 is like a star\n  GTE0: createToken('^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$'),\n  GTE0PRE: createToken('^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$'),\n}\n\n// parse out just the options we care about so we always get a consistent\n// obj with keys in a consistent order.\nconst opts = ['includePrerelease', 'loose', 'rtl']\nexport const parseOptions = options =>\n  !options ? {}\n    : typeof options !== 'object' ? { loose: true }\n      : opts.filter(k => options[k]).reduce((o, k) => {\n        o[k] = true\n        return o\n      }, {})\n\nexport const numeric = /^[0-9]+$/;\n\n/**\n * Compares two identifiers, must be numeric strings or truthy/falsy values.\n *\n * Sorts in ascending order when passed to `Array.sort()`.\n */\nexport const compareIdentifiers = (a: string | number, b: string | number): 1 | 0 | -1 => {\n  const anum = numeric.test(a as string);\n  const bnum = numeric.test(b as string);\n\n  let _a: number | string = a;\n  let _b: number | string = b;\n\n  if (anum && bnum) {\n    _a = +a;\n    _b = +b;\n  }\n\n  return _a === _b ? 0\n    : (anum && !bnum) ? -1\n      : (bnum && !anum) ? 1\n        : _a < _b ? -1\n          : 1\n}\n\nexport interface Options {\n  loose?: boolean | undefined;\n  includePrerelease?: boolean | undefined;\n}\n\nexport class SemVer {\n  raw: string;\n  loose: boolean;\n  options: Options;\n\n  major: number;\n  minor: number;\n  patch: number;\n  version: string;\n  build: ReadonlyArray<string>;\n  prerelease: ReadonlyArray<string | number>;\n  includePrerelease: boolean | undefined;\n\n  constructor(version: string | SemVer, options?: boolean | Options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n        version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? tokens.LOOSE.regex : tokens.FULL.regex)\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format() {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString() {\n    return this.version\n  }\n\n  /**\n   * Compares two versions excluding build identifiers (the bit after `+` in the semantic version string).\n   *\n   * @return\n   * - `0` if `this` == `other`\n   * - `1` if `this` is greater\n   * - `-1` if `other` is greater.\n   */\n  compare(other: string | SemVer): 1 | 0 | -1 {\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  /**\n   * Compares the release portion of two versions.\n   *\n   * @return\n   * - `0` if `this` == `other`\n   * - `1` if `this` is greater\n   * - `-1` if `other` is greater.\n   */\n  compareMain(other: string | SemVer): 1 | 0 | -1 {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  /**\n   * Compares the prerelease portion of two versions.\n   *\n   * @return\n   * - `0` if `this` == `other`\n   * - `1` if `this` is greater\n   * - `-1` if `other` is greater.\n   */\n  comparePre(other: string | SemVer): 1 | 0 | -1 {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n}\n\nexport const ANY = Symbol('SemVer ANY')\n\nexport type ComparatorOperator = '' | '=' | '<' | '>' | '<=' | '>=';\nexport class Comparator {\n  semver: SemVer | typeof ANY;\n  operator: ComparatorOperator;\n  value: string;\n  loose: boolean;\n  options: Options;\n\n  constructor(comp: string | Comparator, optionsOrLoose?: boolean | Options) {\n    optionsOrLoose = parseOptions(optionsOrLoose)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!optionsOrLoose.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    this.options = optionsOrLoose\n    this.loose = !!optionsOrLoose.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n  }\n\n  parse(comp: string) {\n    const r = this.options.loose ? tokens.COMPARATORLOOSE.regex : tokens.COMPARATOR.regex\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = (m[1] !== undefined ? m[1] : '') as ComparatorOperator\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString() {\n    return this.value\n  }\n}\n\nconst cache = new Map<string, Comparator[]>();\nconst cacheLastAccessTime = new Map<string, number>();\nconst cacheLimit = 1000;\n\nexport const caretTrimReplace = '$1^';\nexport const tildeTrimReplace = '$1~';\nexport const comparatorTrimReplace = '$1$2$3';\n\nexport const isNullSet = c => c.value === '<0.0.0-0'\nexport const isAny = c => c.value === ''\n\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nexport const parseComparator = (comp, options) => {\n  comp = replaceCarets(comp, options)\n  comp = replaceTildes(comp, options)\n  comp = replaceXRanges(comp, options)\n  comp = replaceStars(comp, options)\n  return comp\n}\n\nexport const isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nexport const replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((c) => {\n    return replaceTilde(c, options)\n  }).join(' ')\n\nexport const replaceTilde = (comp, options) => {\n  const r = options.loose ? tokens.TILDELOOSE.regex : tokens.TILDE.regex\n  return comp.replace(r, (_, M, m, p, pr) => {\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      ret = `>=${M}.${m}.${p}-${pr\n        } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n        } <${M}.${+m + 1}.0-0`\n    }\n\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nexport const replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((c) => {\n    return replaceCaret(c, options)\n  }).join(' ')\n\nexport const replaceCaret = (comp, options) => {\n  const r = options.loose ? tokens.CARETLOOSE.regex : tokens.CARET.regex\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n            } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n            } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n          } <${+M + 1}.0.0-0`\n      }\n    } else {\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n            }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n            }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n          } <${+M + 1}.0.0-0`\n      }\n    }\n\n    return ret\n  })\n}\n\nexport const replaceXRanges = (comp, options) => {\n  return comp.split(/\\s+/).map((c) => {\n    return replaceXRange(c, options)\n  }).join(' ')\n}\n\nexport const replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? tokens.XRANGELOOSE.regex : tokens.XRANGE.regex\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n        } <${M}.${+m + 1}.0-0`\n    }\n\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nexport const replaceStars = (comp, options) => {\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(tokens.STAR.regex, '')\n}\n\nexport const replaceGTE0 = (comp, options) => {\n  return comp.trim()\n    .replace(tokens[options.includePrerelease ? 'GTE0PRE' : 'GTE0'].regex, '')\n}\n\n// This function is passed to string.replace(tokens.HYPHENRANGE.regex)\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nexport const hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nexport const testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      if (set[i].semver === ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n          allowed.minor === version.minor &&\n          allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\n// hoisted class for cyclic dependency\nexport class Range {\n  range: string;\n  raw: string;\n  loose: boolean;\n  options: Options;\n  includePrerelease: boolean;\n  set: ReadonlyArray<ReadonlyArray<Comparator>>;\n\n  constructor(range: string | Range, optionsOrLoose?: boolean | Options) {\n    optionsOrLoose = parseOptions(optionsOrLoose)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!optionsOrLoose.loose &&\n        range.includePrerelease === !!optionsOrLoose.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, optionsOrLoose)\n      }\n    }\n\n    this.options = optionsOrLoose\n    this.loose = !!optionsOrLoose.loose\n    this.includePrerelease = !!optionsOrLoose.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.format()\n  }\n\n  format() {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString() {\n    return this.range\n  }\n\n  parseRange(range: string): ReadonlyArray<Comparator> {\n    range = range.trim()\n\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts = Object.keys(this.options).join(',')\n    const memoKey = `parseRange:${memoOpts}:${range}`\n    if (cache.has(memoKey)) {\n      cacheLastAccessTime.set(memoKey, Date.now());\n      return cache.get(memoKey);\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? tokens.HYPHENRANGELOOSE.regex : tokens.HYPHENRANGE.regex\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(tokens.COMPARATORTRIM.regex, comparatorTrimReplace)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(tokens.TILDETRIM.regex, tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(tokens.CARETTRIM.regex, caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        return !!comp.match(tokens.COMPARATORLOOSE.regex)\n      })\n    }\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    let cacheValue = result;\n    cache.set(memoKey, cacheValue);\n    cacheLastAccessTime.set(memoKey, Date.now());\n\n    if (cache.size >= cacheLimit) {\n      let sortedCacheItems = [...cacheLastAccessTime.entries()].sort((a, b) => a[1] - b[1]);\n      let oldestKey = sortedCacheItems[0][0];\n\n      cache.delete(oldestKey);\n      cacheLastAccessTime.delete(oldestKey);\n    }\n    return result\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test(version: string | SemVer): boolean {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\n/**\n * Return the highest version in the list that satisfies the range, or null if none of them do.\n */\nexport function maxSatisfying<T extends string | SemVer>(versions: ReadonlyArray<T>, range: string | Range, optionsOrLoose?: boolean | Options): T | null {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, optionsOrLoose)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, optionsOrLoose)\n      }\n    }\n  })\n  return max\n}\n\nexport default maxSatisfying;","import { getRequest } from \"./fetch-and-cache\";\nimport { parsePackageName } from \"./parse-package-name\";\nimport { maxSatisfying } from \"./semver\";\n\n/**\n * Returns registry url for packages which have an input string\n * \n * @param input package to generate npm registry url for; it supports adding package versions \"@okikio/animate@1.0\"\n * @returns the proper npm registry url with package input package versions etc...\n */\nexport const getRegistryURL = (input: string) => {\n  const host = \"https://registry.npmjs.com\";\n\n  let { name, version, path } = parsePackageName(input);\n  let searchURL = `${host}/-/v1/search?text=${encodeURIComponent(name)}&popularity=0.5&size=30`;\n  let packageVersionURL = `${host}/${name}/${version}`;\n  let packageURL = `${host}/${name}`;\n\n  return { searchURL, packageURL, packageVersionURL, version, name, path };\n};\n\n/**\n * Searches the npm registry for packages with matching names\n * \n * @param input package name to search for; it supports adding package versions \"@okikio/animate@1.0\", but will ignore them\n * @returns resulting package info.\n */\nexport const getPackages = async (input: string) => {\n  let { searchURL } = getRegistryURL(input);\n  let result: any;\n\n  try {\n    let response = await getRequest(searchURL, false);\n    result = await response.json();\n  } catch (e) {\n    console.warn(e);\n    throw e;\n  }\n\n  let packages = result?.objects;\n  return { packages, info: result };\n}\n\n/**\n * Searches the npm registry for a package with the same name\n * \n * @param input package name to search for; it supports adding package versions \"@okikio/animate@1.0\", but will ignore them\n * @returns resulting package info.\n */\nexport const getPackage = async (input: string) => {\n  let { packageURL } = getRegistryURL(input);\n\n  try {\n    let response = await getRequest(packageURL, false);\n    return await response.json();\n  } catch (e) {\n    console.warn(e);\n    throw e;\n  }\n}\n\n/**\n * Searches the npm registry for a package an lists out all it versions with an object of available { versions, tags }.\n * \n * @param input package name to search for; it supports adding package versions \"@okikio/animate@1.0\", but will ignore them\n * @returns resulting package info.\n */\nexport const getPackageVersions = async (input: string) => {\n  try {\n    let pkg = await getPackage(input);\n    let versions = Object.keys(pkg.versions);\n    let tags = pkg['dist-tags'];\n    return { versions, tags };\n  } catch (e) {\n    console.warn(e);\n    throw e;\n  }\n}\n\n/**\n * Searches the npm registry for a package with matching names\n * \n * @param input package name to search for; it supports adding package versions \"@okikio/animate@1.0\", and will use that to resolve the package version\n * @returns resulting package info.\n */\nexport const resolveVersion = async (input: string) => {\n  try {\n    let { version: range } = getRegistryURL(input);\n    let versionsAndTags = await getPackageVersions(input);\n    if (versionsAndTags) {\n      const { versions, tags } = versionsAndTags;\n\n      if (range in tags) {\n        range = tags[range];\n      }\n\n      return versions.includes(range)\n        ? range\n        : maxSatisfying(versions, range) as string;\n    }\n  } catch (e) {\n    console.warn(e);\n    throw e;\n  }\n}\n/**\n * Searches the npm registry for a package with the same name, it then resolves the package version making sure it's valid, and give the appropriate package that matches the version set\n * \n * @param input package name to search for; it supports adding package versions \"@okikio/animate@1.0\", and will use that to resolve the package version\n * @returns resulting package info.\n */\nexport const getResolvedPackage = async (input: string) => {\n  try {\n    let { name } = getRegistryURL(input);\n    let version = await resolveVersion(input); \n    return await getPackage(`${name}@${version}`);\n  } catch (e) {\n    console.warn(e);\n    throw e;\n  }\n}","// https://deno.land/x/brotli@v0.1.4/mod.ts\n// Copyright 2020-present the denosaurs team. All rights reserved. MIT license.\n// import init, {\n//     source,\n//     compress as wasm_compress,\n//     decompress as wasm_decompress,\n// } from \"./wasm\";\n\nlet initialized = false;\nlet initWASM: typeof import(\"./wasm\");\nexport const getWASM = async () => {\n    if (initWASM) return initWASM;\n\n    const wasm = await import(\"./wasm\");\n    const { default: init, source } = wasm;\n    \n    if (!initialized) await init(await source());\n    return (initWASM = wasm);\n}\n\n/**\n * Compress a byte array.\n *\n * ```typescript\n * import { compress } from \"https://deno.land/x/brotli/mod.ts\";\n * const text = new TextEncoder().encode(\"X\".repeat(64));\n * console.log(text.length);                   // 64 Bytes\n * console.log(compress(text).length);         // 10 Bytes\n * ```\n *\n * @param input Input data.\n * @param bufferSize Read buffer size\n * @param quality Controls the compression-speed vs compression-\n * density tradeoff. The higher the quality, the slower the compression.\n * @param lgwin Base 2 logarithm of the sliding window size.\n */\nexport async function compress(\n    input: Uint8Array,\n    bufferSize: number = 4096,\n    quality: number = 6,\n    lgwin: number = 22,\n): Promise<Uint8Array> {\n    const { compress } = await getWASM();\n    return compress(input, bufferSize, quality, lgwin);\n}\n\n/**\n * Decompress a byte array.\n *\n * ```typescript\n * import { decompress } from \"https://deno.land/x/brotli/mod.ts\";\n * const compressed = Uint8Array.from([ 27, 63, 0, 0, 36, 176, 226, 153, 64, 18 ]);\n * console.log(compressed.length);             // 10 Bytes\n * console.log(decompress(compressed).length); // 64 Bytes\n * ```\n *\n * @param input Input data.\n * @param bufferSize Read buffer size\n */\nexport async function decompress(\n    input: Uint8Array,\n    bufferSize: number = 4096,\n): Promise<Uint8Array> {\n    const { decompress } = await getWASM();\n    return decompress(input, bufferSize);\n}","// https://deno.land/x/denoflate@1.2.1/mod.ts\n// export {\n//   deflate,\n//   inflate,\n//   gzip,\n//   gunzip,\n//   zlib,\n//   unzlib\n// } from \"./pkg/denoflate.js\";\n\nimport type { InitOutput } from \"./pkg/denoflate\";\n// import init from \"./pkg/denoflate.js\"; \n\n// @ts-ignore\n// import { wasm as WASM } from \"./pkg/denoflate_bg.wasm.js\";\n// import { source } from \"./pkg/wasm.ts\";\n\nlet wasm: InitOutput;\nlet initWASM: typeof import(\"./pkg/denoflate.js\");\nexport const getWASM = async (src?: Uint8Array) => {\n  if (initWASM) return initWASM;\n\n  const _exports = await import(\"./pkg/denoflate.js\");\n  const { default: init } = _exports;\n\n  const { wasm: WASM } = (await import(\"./pkg/denoflate_bg.wasm.js\")) as unknown as { wasm: () => Promise<Uint8Array> };\n  (wasm = await init(src ?? await WASM()));\n\n  return (initWASM = _exports);\n}\n\nexport async function deflate(input: Uint8Array, compression?: number) {\n  return (await getWASM()).deflate(input, compression);\n}\n\nexport async function inflate(input: Uint8Array) {\n  return (await getWASM()).inflate(input);\n}\n\nexport async function gzip(input: Uint8Array, compression?: number) {\n  return (await getWASM()).gzip(input, compression);\n}\n\nexport async function gunzip(input: Uint8Array) {\n  return (await getWASM()).gunzip(input);\n}\n\nexport async function zlib(input: Uint8Array, compression?: number) {\n  return (await getWASM()).zlib(input, compression);\n}\n\nexport async function unzlib(input: Uint8Array) {\n  return (await getWASM()).unzlib(input);\n}\n\nexport default wasm;\n","// https://deno.land/x/lz4@v0.1.2/mod.ts\n// Copyright 2020-present the denosaurs team. All rights reserved. MIT license.\n\n// import init, {\n//     source,\n//     lz4_compress,\n//     lz4_decompress,\n// } from \"./wasm\";\n\nlet initialized = false;\nlet initWASM: typeof import(\"./wasm\");\nexport const getWASM = async () => {\n    if (initWASM) return initWASM;\n\n    const wasm = await import(\"./wasm\");\n    const { default: init, source } = wasm;\n    \n    if (!initialized) await init(await source());\n    return (initWASM = wasm);\n}\n\n/**\n * Compress a byte array using lz4.\n *\n * ```typescript\n * import { compress } from \"https://deno.land/x/lz4/mod.ts\";\n * const text = new TextEncoder().encode(\"X\".repeat(64));\n * console.log(text.length);                   // 64 Bytes\n * console.log(compress(text).length);         // 6  Bytes\n * ```\n *\n * @param input Input data.\n */\nexport async function compress(input: Uint8Array): Promise<Uint8Array> {\n    const { lz4_compress } = await getWASM();\n    return lz4_compress(input);\n}\n\n/**\n * Decompress a byte array using lz4.\n *\n * ```typescript\n * import { decompress } from \"https://deno.land/x/lz4/mod.ts\";\n * const compressed = Uint8Array.from([ 31, 88, 1, 0, 44, 0 ]);\n * console.log(compressed.length);             // 6 Bytes\n * console.log(decompress(compressed).length); // 64 Bytes\n * ```\n *\n * @param input Input data.\n */\nexport async function decompress(input: Uint8Array): Promise<Uint8Array> {\n    const { lz4_decompress } = await getWASM();\n    return lz4_decompress(input);\n}","// https://deno.land/std@0.61.0/encoding/base64.ts\n// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\n\n/**\n * Converts given data with base64 encoding\n * @param data input to encode\n */\n export function encode(data: string | ArrayBuffer): string {\n  if (typeof data === \"string\") {\n    return btoa(data);\n  } else {\n    const d = new Uint8Array(data);\n    let dataString = \"\";\n    for (let i = 0; i < d.length; ++i) {\n      dataString += String.fromCharCode(d[i]);\n    }\n\n    return btoa(dataString);\n  }\n}\n\n/**\n * Converts given base64 encoded data back to original\n * @param data input to decode\n */\nexport function decode(data: string): ArrayBuffer {\n  const binaryString = decodeString(data);\n  const binary = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binary.length; ++i) {\n    binary[i] = binaryString.charCodeAt(i);\n  }\n\n  return binary.buffer;\n}\n\n/**\n * Decodes data assuming the output is in string type\n * @param data input to decode\n */\nexport function decodeString(data: string): string {\n  return atob(data);\n}"],"names":["encode","decode","sep","delimiter","normalize","resolve","isAbsolute","path","join","EventEmitter","ansi","initWASM","getWASM"],"mappings":"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"}